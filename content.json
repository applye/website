{"meta":{"title":"小橙","subtitle":"小橙个人博客网站","description":"个人博客网站","author":"xiao cheng","url":"//website.cwzcfj.cn","root":"/"},"pages":[],"posts":[{"title":"","slug":"tab导航组件","date":"2021-08-27T15:21:15.292Z","updated":"2022-09-04T09:38:21.223Z","comments":true,"path":"2021/08/27/tab导航组件/","link":"","permalink":"//website.cwzcfj.cn/2021/08/27/tab导航组件/","excerpt":"","text":"abbrlink: 1title: React-native之开源Tab导航组件categories: ‘前端’tags: ‘前端’ ‘react-native’comments: falsedate: 2019-04-15 22:12:38img: ‘https://raw.githubusercontent.com/879733672/images/cdn/img/202209041737718.jpg&#39;React-native之开源Tab导航组件 简介大多数应用都会有导航进行页面切换，React Native原生的控件仅有TabBarIOS可供iOS平台使用，如果想同时适配Android和IOS,最好使用第三方控件，比如:react-native-tab-navigator地址:https://github.com/exponent/react-native-tab-navigator 二. 使用(1).安装 项目根目录下 使用命令行安装 1npm install react-native-tab-navigator --save (2).导入1import TabNavigator from 'react-native-tab-navigator'; (3).代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import React, &#123; Component &#125; from 'react'import &#123; AppRegistry, StyleSheet, Text, View, Image, WebView, ListView,&#125; from 'react-native'import TabNavigator from 'react-native-tab-navigator'/** * * TabNavigator 使用示例 * @export HomeUI * @class HomeUI * @extends &#123;Component&#125; */export default class HomeUI extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; selectedTab: 'home', &#125;; &#125; /** * * * @returns * * @memberOf HomeUI */ render() &#123; const homeView = ( &lt;View style=&#123;[styles.flex, styles.center, &#123; backgroundColor: '#ffff0044' &#125;]&#125;&gt; &lt;Text style=&#123;&#123; fontSize: 22 &#125;&#125;&gt;我是主页&lt;/Text&gt; &lt;/View&gt; ) const settingView = ( &lt;View style=&#123;[styles.flex, styles.center, &#123; backgroundColor: '#ffff0044' &#125;]&#125;&gt; &lt;Text style=&#123;&#123; fontSize: 22 &#125;&#125;&gt;我是设置页面&lt;/Text&gt; &lt;/View&gt; ) return ( ' &lt;TabNavigator hidesTabTouch=&#123;true&#125; tabBarStyle=&#123;&#123; height: 60 &#125;&#125; &gt; &lt;TabNavigator.Item selected=&#123;this.state.selectedTab === 'home'&#125; title='主页' renderIcon=&#123;() =&gt; &lt;Image source=&#123;require('./images/home_tab_home_normal.png')&#125; /&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Image source=&#123;require('./images/home_tab_home_pressed.png')&#125; /&gt;&#125; badgeText='200' onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'home' &#125;)&#125;&gt; &#123;homeView&#125; &lt;/TabNavigator.Item&gt; &lt;TabNavigator.Item selected=&#123;this.state.selectedTab === 'setting'&#125; title='设置' renderIcon=&#123;() =&gt; &lt;Image source=&#123;require('./images/home_tab_setting_normal.png')&#125; /&gt;&#125; renderSelectedIcon=&#123;() =&gt; &lt;Image source=&#123;require('./images/home_tab_setting_pressed.png')&#125; /&gt;&#125; onPress=&#123;() =&gt; this.setState(&#123; selectedTab: 'setting' &#125;)&#125;&gt; &#123;settingView&#125; &lt;/TabNavigator.Item&gt; &lt;/TabNavigator&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; flex: &#123; flex: 1, &#125;, ListView: &#123; paddingTop: 20, backgroundColor: '#F5FCFF', &#125;, img: &#123; width: 40, height: 33, &#125;, center: &#123; justifyContent: 'center', alignItems: 'center', &#125;,&#125;); center: { justifyContent: &apos;center&apos;, alignItems: &apos;center&apos;, }, }); `","categories":[],"tags":[]},{"title":"React Native 第三方组件react-native-side-menu -侧滑栏使用","slug":"side侧滑栏组件","date":"2021-08-27T15:21:15.290Z","updated":"2022-09-04T08:39:15.164Z","comments":false,"path":"2021/08/27/side侧滑栏组件/","link":"","permalink":"//website.cwzcfj.cn/2021/08/27/side侧滑栏组件/","excerpt":"","text":"React Native 第三方组件react-native-side-menu -侧滑栏使用简介 添加应用侧滑功能， 使用第三方组件。比如：react-native-side-menu。 地址：https://github.com/react-native-community/react-native-side-menu (1). 安装1npm install react-native-side-menu --save (2). 导入1import SideMenu from 'react-native-side-menu'; (3). 出现的错误1Warning: setState(...): Cannot update during an existing state transition (such as within `render` or another component's constructor). Render methods should be a pure function of props and state; constructor side-effects are an anti-pattern, but can be moved to `componentWillMount`. 大体意思是说render 在这种需要props和state进行渲染的方法中，不能在对props和state进行更新。 React 会在state和props改变的时候调用render进行DOM diff然后渲染，如果渲染在对props和state进行更新，就进入死循环。 解决办法：在调用方法时创建一个匿名函数，再调用。 (4).代码示例 homeUI.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import React, &#123; Component &#125; from 'react'import &#123; AppRegistry, StyleSheet, Text, View, Image, WebView, ListView, ScrollView, navigator, TouchableOpacity,&#125; from 'react-native'import SideMenu from 'react-native-side-menu'import Menu from './menu'/** * * SideMenu 使用示例 * @export HomeUI * @class HomeUI * @extends &#123;Component&#125; */export default class HomeUI extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isOpen: false, selectedItem: 'About', &#125;; &#125; onMenuItemSelected = (item) =&gt; &#123; this.setState(&#123; isOpen: false, selectedItem: item, &#125;) &#125; updateMenu(isOpen) &#123; this.setState(&#123; isOpen: isOpen &#125;); &#125; toggle() &#123; this.setState(&#123; isOpen: !this.state.isOpen &#125;); &#125; render() &#123; const menu = &lt;Menu onItemSelected=&#123;this.onMenuItemSelected&#125; navigator=&#123;navigator&#125; /&gt;; return ( &lt;SideMenu menu=&#123;menu&#125; isOpen=&#123;this.state.isOpen&#125; onChange=&#123;(isOpen) =&gt; this.updateMenu(isOpen)&#125;&gt; &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;&#123; fontSize: 20, textAlign: 'center', margin: 10 &#125;&#125;&gt;hello world react native&lt;/Text&gt; &lt;Text&gt; 选中菜单是： &#123;this.state.selectedItem&#125; &lt;/Text&gt; &lt;/View&gt; &lt;TouchableOpacity style=&#123;styles.button&#125; onPress=&#123;() =&gt; this.toggle()&#125;&gt; &lt;Image style=&#123;&#123; width: 32, height: 32 &#125;&#125; source=&#123;require('./images/image_menu.png')&#125; /&gt; &lt;/TouchableOpacity&gt; &lt;/SideMenu&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; flex: &#123; flex: 1, &#125;, ListView: &#123; paddingTop: 20, backgroundColor: '#F5FCFF', &#125;, container: &#123; flex: 1, backgroundColor: '#F5FCFF', justifyContent: 'center', alignItems: 'center', &#125;, button: &#123; position: 'absolute', top: 20, padding: 10, &#125;,&#125;);menu.jsimport React,&#123;Component&#125; from 'react'import &#123; AppRegistry, StyleSheet, Dimensions, ScrollView, Text, Image, View,&#125; from 'react-native'const window = Dimensions.get('window');/** * 菜单组件 * * @class Menu* @extends &#123;Component&#125; */class Menu extends Component &#123; static PropTypes = &#123; onItemSelected: React.PropTypes.func.isRequired, &#125;; render() &#123; return( &lt;ScrollView scrollsToTop=&#123;false&#125; style=&#123;styles.menu&#125;&gt; &lt;View style=&#123;styles.avatarConent&#125;&gt; &lt;Image style=&#123;styles.avatar&#125; source=&#123;require('./images/avatar.jpg')&#125; /&gt; &lt;Text style=&#123;styles.name&#125;&gt; 小程QQ昵称&lt;/Text&gt; &lt;/View&gt; &lt;Text onPress=&#123;() =&gt; this.props.onItemSelected('作者')&#125; style=&#123;styles.item&#125;&gt; 作者 &lt;/Text&gt; &lt;Text onPress=&#123;() =&gt; this.props.onItemSelected('联系美丽蓝天')&#125; style=&#123;styles.item&#125;&gt; 联系美丽蓝天 &lt;/Text&gt; &lt;/ScrollView&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; menu: &#123; flex:1, width: window.width, height: window.height, backgroundColor: 'gray', padding: 20, &#125;, avatarConent: &#123; marginBottom: 20, marginTop:20, &#125;, avatar: &#123; width:48, height:48, borderRadius: 24, flex:1, &#125;, name:&#123; position: 'absolute', left: 70, top:20, &#125;, item: &#123; fontSize:16, fontWeight:'300', paddingTop:10, &#125;,&#125;)export default Menu;","categories":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/tags/前端/"},{"name":"React Native","slug":"React-Native","permalink":"//website.cwzcfj.cn/tags/React-Native/"}]},{"title":"前端如何进行npm发布？","slug":"前端如何进行npm发布？","date":"2019-05-14T14:50:16.000Z","updated":"2022-09-04T08:47:13.455Z","comments":false,"path":"2019/05/14/前端如何进行npm发布？/","link":"","permalink":"//website.cwzcfj.cn/2019/05/14/前端如何进行npm发布？/","excerpt":"","text":"前端npm包发布 在npm官网上注册一个账号，https://www.npmjs.com/. 之后别忘了验证邮箱。 新建一个目录，比如all-web, 使用命令进入到这个目录，执行npm init, 初始化，按照提示填写对应的内容信息。 1234567891011121314151617package name：填写你这个包的名字，默认是你这个文件夹的名字（nodeadd）version：填写你这个包的版本，默认1.0.0description：描述一下你这个包是干嘛用的entry point：入口文件，默认是index.js，你也可以自己填写你自己的文件名test command：测试命令，默认为空，直接回车就行git repository：git仓库地址，如果你的包是先放到github上或者其他git仓库里，这时候你的文件夹里面会存在一个隐藏的.git目录，npm会读到这个目录作为这一项的默认值。如果没有的话，直接回车继续。keywords：关键词，方便别人搜到这个包author：你的账号license： 你的这个包遵循什么开源协议，直接回车就行 编写自己的项目包，可以是脚手架等 发布npm包 npm源切换注意一般因为网络速度，原因一般使用taobao镜像，发布时需要切换会官网镜像 1npm config set registry http://registry.npmjs.org/ npm登录 12npm adduser # 添加账号npm login # 登录账号 接下来会以问答形式向你了解你的用户名、密码以及公开的邮箱，之后输入：1npm publish 看到进度条，之后发布成功。 查询发布的包npm官网全局搜索即可，淘宝npm等镜像同步时间到搜索. 如何撤销发布的包(撤包有时间限制，24小时)终端执行 npm unpublish例如：(1). npm unpublish all-web@1.0.0 删除某个版本(2). npm unpublish all-web –force 删除整个npm市场的包 npm unpublish的推荐替代命令：npm deprecate [@] 使用这个命令，并不会在社区里撤销你已有的包，但会在任何人尝试安装这个包的时候得到警告例如：npm deprecate z-tool ‘这个包我已经不再维护了哟～’ 【注意】如果报权限方面的错，加上–force","categories":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/tags/前端/"},{"name":"npm","slug":"npm","permalink":"//website.cwzcfj.cn/tags/npm/"}]},{"title":"前端脚手架搭建","slug":"前端脚手架搭建","date":"2019-05-07T13:25:14.000Z","updated":"2022-09-04T08:49:14.388Z","comments":false,"path":"2019/05/07/前端脚手架搭建/","link":"","permalink":"//website.cwzcfj.cn/2019/05/07/前端脚手架搭建/","excerpt":"","text":"前端脚手架搭建在实际开发过程中，从零开始建立项目的结构是一件让人头疼的事情，所以各种各样的脚手架工具运用而生。使用较多的yoeman,express-generato,create-react-appr和vue-cli便是当中之一。它们功能丰富，但最核心的功能都是能够快速搭建一个完整的项目结构，开发者只需要在生成的项目结构基础上进行开发即可，非常简单高效。 为什么需要需要脚手架？ 减少重复性的工作，不再需要复制其他项目再删除无关代码，或者从零创建一个项目和文件 根据交互动态生成项目结构和配置文件等。 我们可以借鉴 vue-cli 的基本思路。vue-cli 是将项目模板放在 git 上，运行的时候再根据用户交互下载不同的模板，经过模板引擎渲染出来，生成项目。这样将模板和脚手架分离，就可以各自维护，即使模板有变动，只需要上传最新的模板即可，而不需要用户去更新脚手架就可以生成最新的项目。那么就可以按照这个思路来进行开发了。 第三方库 commander.js，可以自动的解析命令和参数，用于处理用户输入的命令。 download-git-repo，下载并提取 git 仓库，用于下载项目模板。 Inquirer.js，通用的命令行用户界面集合，用于和用户进行交互。 handlebars.js，模板引擎，将用户提交的信息动态填充到文件中。 ora，下载过程久的话，可以用于显示下载中的动画效果。 chalk，可以给终端的字体加上颜色。 log-symbols，可以在终端上显示出 √ 或 × 等的图标。 初始化项目首先创建一个空项目，暂时命名为 all-cli，然后新建一个 cli.js 文件，再执行 npm init 生成一个 package.json 文件。最后安装上面需要用到的依赖。 12345mkdir all-cli &amp;&amp; cd all-clinpm initnpm install commander download-git-repo inquirer handlebars ora chalk log-symbols -S 处理命令行node.js 内置了对命令行操作的支持，在 package.json 中的 bin 字段可以定义命令名和关联的执行文件。所以现在 package.json 中加上 bin 的内容：1234567891011121314151617181920212223&#123; \"name\": \"all-cli\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"bin\": &#123; \"all-cli\": \"bin/cli.js\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"chalk\": \"^2.4.2\", \"commander\": \"^2.20.0\", \"download-git-repo\": \"^1.1.0\", \"handlebars\": \"^4.1.2\", \"inquirer\": \"^6.3.1\", \"log-symbols\": \"^3.0.0\", \"ora\": \"^3.4.0\" &#125;&#125; 然后在cli.js中定义init命令：12345678#!/usr/bin/env nodeconst program = require('commander');program.version('1.0.0', '-v, --version') .command('init &lt;name&gt;') .action((name) =&gt; &#123; console.log(name); &#125;);program.parse(process.argv); 调用 version(‘1.0.0’, ‘-v, –version’) 会将 -v 和 –version 添加到命令中，可以通过这些选项打印出版本号。调用 command(‘init ‘) 定义 init 命令，name 则是必传的参数，为项目名。action() 则是执行 init 命令会发生的行为，要生成项目的过程就是在这里面执行的，这里暂时只打印出 name。这里已经可以执行 init 命令了。执行：1node bin/cli.js init HelloWorld 可以看到命令行工具也打印出了 HelloWorld，那么很清楚， action((name) =&gt; {}) 这里的参数 name，就是我们执行 init 命令时输入的项目名称。命令已经完成，接下来就要下载模板生成项目结构了。 下载模板download-git-repo 支持从 Github、Gitlab 和 Bitbucket 下载仓库，各自的具体用法可以参考官方文档。 1234567891011#!/usr/bin/env nodeconst program = require('commander');const download = require('download-git-repo');program.version('1.0.0', '-v, --version') .command('init &lt;name&gt;') .action((name) =&gt; &#123; download('gitlab:xx#master', name, &#123;clone: true&#125;, (err) =&gt; &#123; console.log(err ? 'Error' : 'Success') &#125;) &#125;);program.parse(process.argv); 命令行交互命令行交互功能可以在用户执行 init 命令后，向用户提出问题，接收用户的输入并作出相应的处理。这里使用 inquirer.js 来实现。 12345678910const inquirer = require('inquirer');inquirer.prompt([ &#123; type: 'input', name: 'author', message: 'author' &#125;]).then((answers) =&gt; &#123; console.log(answers.author);&#125;) 通过这里例子可以看出，问题就放在 prompt() 中，问题的类型为 input 就是输入类型，name 就是作为答案对象中的 key，message 就是问题了，用户输入的答案就在 answers 中，使用起来就是这么简单。更多的参数设置可以参考官方文档。通过命令行交互，获得用户的输入，从而可以把答案渲染到模板中。 渲染模板这里用 handlebars 的语法对仓库的模板中的 package.json 文件做一些修改12345678910&#123; \"name\": \"&#123;&#123;name&#125;&#125;\", \"author\": \"&#123;&#123;author&#125;&#125;\", \"version\": \"&#123;&#123;version&#125;&#125;\", \"description\": \"&#123;&#123;description&#125;&#125;\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"license\": \"ISC\"&#125; 并在下载模板完成之后将用户输入的答案渲染到 package.json 中1234567891011121314151617181920212223242526program.version('1.0.0', '-v, --version').command('init &lt;name&gt;').action((name) =&gt; &#123; inquirer.prompt([ &#123; name: 'description', message: 'description' &#125;, &#123; name: 'author', message: 'author' &#125; ]).then((answers) =&gt; &#123; download('gitlab:xxxx#master',name,&#123;clone: true&#125;,(err) =&gt; &#123; const meta = &#123; name, description: answers.description, author: answers.author &#125; const fileName = `$&#123;name&#125;/package.json`; const content = fs.readFileSync(fileName).toString(); const result = handlebars.compile(content)(meta); fs.writeFileSync(fileName, result); &#125;) &#125;)&#125;); 这里使用了 node.js 的文件模块 fs，将 handlebars 渲染完后的模板重新写入到文件中。 视觉美化在用户输入答案之后，开始下载模板，这时候使用 ora 来提示用户正在下载中。12345678const ora = require('ora');// 开始下载const spinner = ora('The template is being downloaded...');spinner.start();// 下载失败调用spinner.fail();// 下载成功调用spinner.succeed(); 然后通过 chalk 来为打印信息加上样式，比如成功信息为绿色，失败信息为红色，这样子会让用户更加容易分辨，同时也让终端的显示更加的好看。123const chalk = require('chalk');console.log(chalk.green('Success'));console.log(chalk.red('Fail')); 除了给打印信息加上颜色之外，还可以使用 log-symbols 在信息前面加上 √ 或 × 等的图标。1234const chalk = require('chalk');const symbols = require('log-symbols');console.log(symbols.success, chalk.green('Success'));console.log(symbols.error, chalk.red('Fail')); 完整示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#! /usr/bin/env nodeconst program = require('commander');const download = require('download-git-repo');const inquirer = require('inquirer');const handlebars = require('handlebars');const ora = require('ora');const chalk = require('chalk');const symbols = require('log-symbols');const fs = require(\"fs\");program.version('1.0.0', '-v', '--version') .command('init &lt;name&gt;') .action((name) =&gt; &#123; if (!fs.existsSync(name)) &#123; inquirer.prompt([ &#123; type: 'list', choices: ['umi', 'react-webpack', 'react-antd'], name: 'platform', message: 'Please select the project you want to install.' &#125;, &#123; name: 'version', message: 'version:(1.0.0)' &#125;, &#123; name: 'description', message: 'description:' &#125;, &#123; name: 'author', message: 'author:' &#125;]).then((answers) =&gt; &#123; console.log(answers.author); const spinner = ora('The template is being downloaded...'); const platform = answers.platform; spinner.start(); download('https://github.com/879733672/all-web-cli.git#&#123;platform&#125;', name, &#123; clone: true &#125;, (err) =&gt; &#123; if (err) &#123; spinner.fail(); console.log(symbols.error, chalk.red(err)); &#125; else &#123; spinner.succeed(); const fileName = `&#123;name&#125;/package.json`; const meta = &#123; name, description: answers.description, author: answers.author, version: answers.version || '1.0.0' &#125; if (fs.existsSync(fileName)) &#123; const content = fs.readdirSync(fileName).toString(); const result = handlebars.compile(content)(meta); fs.writeFileSync(fileName, result); &#125; console.log(symbols.success, chalk.green('Done')) &#125; &#125;); &#125;); &#125;else &#123; //错误提示项目已存在，避免覆盖原有项目 console.log(symbols.error, chalk.red(\"Already Existed.\")); &#125; &#125;);program.parse(process.argv); 完成之后，就可以把脚手架发布到 npm 上面，通过 -g 进行全局安装，就可以在自己本机上执行 ice init [name] 来初始化项目，这样便完成了一个简单的脚手架工具了","categories":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/tags/前端/"},{"name":"脚手架","slug":"脚手架","permalink":"//website.cwzcfj.cn/tags/脚手架/"}]},{"title":"IntersectionObserver介绍","slug":"IntersectionObserver介绍","date":"2019-04-20T13:33:12.000Z","updated":"2022-09-04T08:50:48.387Z","comments":false,"path":"2019/04/20/IntersectionObserver介绍/","link":"","permalink":"//website.cwzcfj.cn/2019/04/20/IntersectionObserver介绍/","excerpt":"","text":"IntersectionObserver简介在移动端，有个很重要的概念，叫做懒加载，适用于一些图片资源特别多，ajax数据特别多的页面中，经常会有动态加载数据的场景中，这个时候，我们通常是使用监听scroll或者使用setInterval来判断，元素是否进入视图，其中scroll由于其特别大的计算量，会有性能问题，而setInterval由于其有间歇期，也会出现体验问题。浏览器的开发商，估计也发现了这个问题，所以在2016年初，chrome51率先提供了一个新的API，就是IntersectionObserver，它可以用来监听元素是否进入了设备的可视区域之内，而不需要频繁的计算来做这个判断。 毕竟是一个新兴的API，所以浏览器的支持性并不好，这里可以看看当前浏览器对于IntersectionObserver的支持性：IntersectionObserver Api简介该API的调用非常简单：1var observer = new IntersectionObserver(callback,options); IntersectionObserver支持两个参数： callback是当被监听元素的可见性变化时，触发的回调函数 options是一个配置参数，可选，有默认的属性值 应用 预加载（滚动加载，无限加载） 懒加载（图片后加载） TAB滚动跟随 事件DOMContentLoaded和load的区别区别是: 触发的时机不一样，先触发DOMContentLoaded事件，后触发load事件。 DOM文档加载的步骤为 解析HTML结构。 DOM树构建完成。//DOMContentLoaded 加载外部脚本和样式表文件。 解析并执行脚本代码。 加载图片等外部文件。 页面加载完毕。//load在第2步，会触发DOMContentLoaded事件。在第6步，触发load事件。 js原生写法：12345678// 不兼容老的浏览器，兼容写法见[jQuery中ready与load事件](http://www.imooc.com/code/3253)，或用jQuerydocument.addEventListener(\"DOMContentLoaded\", function() &#123; // ...代码...&#125;, false);window.addEventListener(\"load\", function() &#123; // ...代码...&#125;, false); jQuery写法123456789// DOMContentLoaded$(document).ready(function() &#123; // ...代码...&#125;);//load$(document).load(function() &#123; // ...代码...&#125;);","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/tags/工具/"},{"name":"IntersectionObserver","slug":"IntersectionObserver","permalink":"//website.cwzcfj.cn/tags/IntersectionObserver/"}]},{"title":"debounce弹跳函数介绍","slug":"debounce弹跳函数介绍","date":"2019-04-20T13:19:48.000Z","updated":"2022-09-04T08:58:08.374Z","comments":false,"path":"2019/04/20/debounce弹跳函数介绍/","link":"","permalink":"//website.cwzcfj.cn/2019/04/20/debounce弹跳函数介绍/","excerpt":"","text":"debounce去弹跳函数 原lodash.debouncedebounce 强制函数再某段时间内只执行一次throttle 强制函数以固定的频率触发的 DOM 事情的时候，他们都能极大提高用户体验. dobounce 返回了一个闭包，这个闭包依然会被连续频繁地调用，但是在闭包内部，却限制了原始函数fn的执行，强制fn只在连续操作停止后只执行一次大致核心代码如下：1234567891011function debounce(fun, delay) &#123; var timer; return function() &#123; var content = this; var args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; fun.apply(content, args); &#125;, delay) &#125;&#125;","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/tags/工具/"},{"name":"debounce","slug":"debounce","permalink":"//website.cwzcfj.cn/tags/debounce/"}]},{"title":"markdown简单使用","slug":"markdown简单使用","date":"2019-04-20T12:07:14.000Z","updated":"2022-09-04T08:59:37.569Z","comments":false,"path":"2019/04/20/markdown简单使用/","link":"","permalink":"//website.cwzcfj.cn/2019/04/20/markdown简单使用/","excerpt":"","text":"markdown简介Markdown 的目标是实现「易读易写」。Markdown 的特点就是，让写作变得更简单，我们不用再考虑如何排版，我们只要专心于写作就好了，这也是对我们的宗旨！！可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。 markdown命令：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621. 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题![百度图片](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3534940874,3350191940&amp;fm=27&amp;gp=0.jpg， '图片')[百度](http://baidu.com)&lt;a href=\"http://baidu.com\" taget=\"_blank\"&gt;百度链接地址&lt;/a&gt;*在哪里***加粗*****斜体加粗***~~删除线~~&gt;这是引用的内容&gt;&gt;这是引用的内容2-------*******表头|表头--|--内容|内容* 在什么地方* 在干啥+ 明天做什么+ 副书记看风景- 开发驾考速度- 空间都是咖啡1. 电视剧法开始2. 的框架开发商的3. 插卡看的积分* 1级无序列表 * 在什么地方 * 世界都是看得见 * 大家福建省客服- 1级无序列表 1. 的框架侃大山 2. 附近富士康福建省 3. 发呆思考当升科技表头|表头|表头--|:--:|--:内容|内容|内容 预览： 标题一级标题二级标题三级标题四级标题五级标题六级标题 百度 百度链接地址 在哪里 加粗 斜体加粗 删除线 这是引用的内容 这是引用的内容2 表头 表头 内容 内容 在什么地方 在干啥 明天做什么 副书记看风景 开发驾考速度 空间都是咖啡 电视剧法开始 的框架开发商的 插卡看的积分 1级无序列表 在什么地方 世界都是看得见 大家福建省客服 1级无序列表 的框架侃大山 附近富士康福建省 发呆思考当升科技 表头 表头 表头 内容 内容 内容 1create database db","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/tags/工具/"},{"name":"markdown","slug":"markdown","permalink":"//website.cwzcfj.cn/tags/markdown/"}]},{"title":"docker学习","slug":"docker学习","date":"2019-04-19T14:24:14.000Z","updated":"2022-09-04T13:01:06.389Z","comments":false,"path":"2019/04/19/docker学习/","link":"","permalink":"//website.cwzcfj.cn/2019/04/19/docker学习/","excerpt":"","text":"docker 简介2013年发布至今，docker一直广受瞩目，被认为可能会改变软件行业。 但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。 1、环境配置的难题软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？ 用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。 如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：”它在我的机器可以跑了”（It works on my machine），言下之意就是，其他机器很可能跑不了。 环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。 2、虚拟机虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。 虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点 资源占用多虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。 冗余步骤多虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 启动慢启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行 对比传统虚拟机总结： 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 3、Linux 容器由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。 启动快 容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 资源占用少 容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 体积小 容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。 4、Docker 是什么？Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 5、docker架构Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。 Docker 容器通过 Docker 镜像来创建。 容器与镜像的关系类似于面向对象编程中的对象与类。 docker 面向对象 容器 对象 镜像 类 镜像Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:14.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。 仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。 6、docker的用途和安装 提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。 提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 docker安装Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。 Docker CE 的安装请参考官方文档。 安装完成后，运行下面的命令，验证是否安装成功。1$ docker version# 或者$ docker info docker 是服务器–客户端架构。命令行运行docker命令的时候，需要本机有docker服务，如果这项服务没有启动，可以用下面的命令启动（官方文档）。1234# service 命令的用法$ sudo service docker start# systemctl 命令的用法$ sudo systemctl start docker 7、image文件Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。1234# 列出本机的所有 image 文件。$ docker image ls# 删除 image 文件$ docker image rm[imageName] image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。 为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库Docker Hub是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。 8、实例：hello world下面，我们通过最简单的 image 文件”hello world”，感受一下 Docker。 首先，运行下面的命令，将 image 文件从仓库抓取到本地。1$ docker image pull library/hello-world 上面代码中，docker image pull是抓取 image 文件的命令。library/hello-world是 image 文件在仓库里面的位置，其中library是 image 文件所在的组，hello-world是 image 文件的名字。 由于 Docker 官方提供的 image 文件，都放在library组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。1$ docker image pull hello-world 抓取成功以后，就可以在本机看到这个 image 文件了1$ docker image ls 现在，运行这个 image 文件。1$ docker container run hello-world docker container run命令会从 image 文件，生成一个正在运行的容器实例。注意，docker container run命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的docker image pull命令并不是必需的步骤。 如果运行成功，你会在屏幕上读到下面的输出。1$ docker container run hello-worldHello from Docker!This message shows that your installation appears to be working correctly....... 输出这段提示以后，hello world就会停止运行，容器自动终止 有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。1$ docker container run-it ubuntu bash 对于那些不会自动终止的容器，必须使用docker container kill命令手动终止。1$ docker container kill[containID] 9、容器文件image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。1234# 列出本机正在运行的容器$ docker container ls# 列出本机所有容器，包括终止运行的容器$ docker container ls--all 上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的docker container kill命令。 终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm命令删除。1$ docker container rm[containerID] 运行上面的命令之后，再使用docker container ls –all命令，就会发现被删除的容器文件已经消失了。 10、Dockerfile文件学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。 这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。 下面通过一个实例，演示如何编写 Dockerfile 文件。 实例：制作自己的 Docker 容器1FROM node:8.4 COPY./app WORKDIR/app RUN npm install--registry=https://registry.npm.taobao.org EXPOSE 3000 上面代码一共五行，含义如下。 FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。 WORKDIR /app：指定接下来的工作路径为/app。 RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。 EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。123$ docker image build-t koa-demo.# 或者$ docker image build-t koa-demo:0.0.1. 上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。如果运行成功，就可以看到新生成的 image 文件koa-demo了。1$ docker image ls 生成容器docker container run命令会从 image 文件生成容器。123$ docker container run -p 8000:3000 -it koa-demo/bin/bash# 或者$ docker container run -p 8000:3000 -it koa-demo:0.0.1/bin/bash 上面命令的各个参数含义如下：-p参数：容器的 3000 端口映射到本机的 8000 端口。 -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。1root@66d80f4aaf1e:/app# 也可以使用docker container run命令的–rm参数，在容器终止运行后自动删除容器文件。1$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash 发布 image 文件 容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去hub.docker.com或cloud.docker.com注册一个账户。然后，用下面的命令登录。1$ docker login 接着，为本地的 image 标注用户名和版本。123$ docker image tag[imageName][username]/[repository]:[tag]# 实例$ docker image tag koa-demos:0.0.1ruanyf/koa-demos:0.0.1 也可以不标注用户名，重新构建一下 image 文件。1$ docker image build-t[username]/[repository]:[tag]. 最后，发布 image 文件。1$ docker image push[username]/[repository]:[tag] 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 11、其他有用的命令前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件 1$ docker container start[containerID] 前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。1$ bash container stop[containerID] 这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。 docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。1$ docker container logs[containerID] docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。1$ docker container exec-it[containerID]/bin/bash docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。1$ docker container cp[containID]:[/path/to/file]. docker文档 命令合集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576docker pull [选项] [docker registry 地址[:端口号]/]仓库名[:标签]例如：docker pull ubuntu:16.04docekr run //运行容器container例如：docker run -it --rm ubuntu:16.04 \\bash-it 这个两个参数，一个-i：交互式操作，-t 终端 bash 执行一些命令查看返回结果，因此需要交互式终端--rm 容器退出后随之删除exit //退出容器//启动一个nginxdocker run -p 8080:80 -d nginxdocker images //列出所有image镜像docker build -t //创建imagedocker ps //列出containerdocker cp index.html b08b3xx://usr/share/nginx/html##提交保存一个镜像docker commit -m 'fun' b08b3xx(容器id) name(名称)# 删除镜像docker rmi b08b3xx# 显示之前运行的历史容器docker ps -a# 删除容器containerdocker rm b08b3xx(容器id) # 在host和container之间拷贝文件docker cp# 查看镜像和任务的详细信息docker inspect ubuntu:latest# 进入容器docker exec -it d5ab172xx /bin/bashdocker attach d5ab172xxssh方式进去# 删除全部容器docker rm $(docker ps -aq)# 一条命令实现停用并删除容器docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)# 查看日志docker logs &lt;container id&gt;# 查看容器内部运行的进程docker top [容器id]# 导出镜像docker expoer &gt; develop.tar# 导入镜像输入命令docker import, 从文件夹中直接把ubuntu文件拖拽到命令行中# 查看空间占用docker system df -v# 自动空间清理docker system prune# 挂载目录docker run -p 8080:80 -d -v $PWD/doc2:/var/www/html cwz/nginx:1.0.0#方式二docker run --volumed-from ...mkdir datadocker create -v $PWD/data:/var/mydata --name data_container ubuntu产生一个仅有数据的容器docker run -it --volumes-from data_container ubuntu /bin/base从一个容器挂载，运行并进入容器内部多容器appcompose介绍 app名称：ghost，是一个博客平台程序，安装之后，可着急写文字或别人发布，架构：nginx-ghost app-mysql 分别分为三个容器 dcoker-compose.yml命令 build: 本地构建镜像 command: 覆盖缺省命令 depends_on: 连接容器 ports: 暴露端口 volumes: 挂载卷组 image: 拉取镜像docker-compose命令 up：启动服务 stop: 停止服务 rm: 删除服务中的各个容器 logs: 观察各个容器中的日志 ps: 列出服务相关的容器 命令 用途 docker pull 获取image docker build 创建image docker run 运行container docker ps 列出container docker rm 删除container docker rmi 删除image docker ps 在host和container之间拷贝文件 docker commit 保存改动为新的image Dockerfile 语法 命令 用途 FROM base image RUN 执行命令 ADD 添加文件 COPY 拷贝文件 CMD 执行命令 EXPOSE 暴露端口 WORKDIR 指定路径 MAINTAINER 维护者 ENV 指定环境变量 ENTRYPOINT 容器入口 USER 指定用户 VOLUME mount point","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/tags/工具/"},{"name":"docker","slug":"docker","permalink":"//website.cwzcfj.cn/tags/docker/"}]},{"title":"前端常用命令集","slug":"前端常用命令集","date":"2019-04-17T15:44:33.000Z","updated":"2022-09-04T09:14:21.324Z","comments":false,"path":"2019/04/17/前端常用命令集/","link":"","permalink":"//website.cwzcfj.cn/2019/04/17/前端常用命令集/","excerpt":"","text":"前端常用命令搜集一些经常使用到的命令，整理到一起，方便查阅。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162mac常用快捷键control+command+f # 最大化最小化切换command+option+i # 打开开发者工具command+H # 隐藏窗口command+M # 最小化当前窗口command+option+H # 最小化当前程序之外所有程序窗口command+option+M+H # 快速隐藏所有应用程序窗口ctrl+shift+L # 同时选中所有匹配mac常用命令pwd # 查看当前工作目录cd # 进入rootcd folder # 进入文件夹cd .. # 上级目录cd ~ # 返回rootrm 文件名 # 删除ls # 列出目录下所有文件cp 文件名 目标目录 # 拷贝到目标目录ps -ef|grep nginx # 查询服务losf -i :7001kill -9 83908 # 查询端口占用，并杀掉ln -s 使用路径 希望的路径 # 链接//查询日志control+f # 翻页//查询日志关键信息cat -n test.log | grep \"地形\"//日志输出到屏幕cat *.logmore *.log # 同cat命令差不多，只不过时会把内容分页，通过空格向下翻页通过less *.log 进入文件 1. 可以通过/txt或者?txt来定位文件，并且通过n(向上)或者N(向下)来定位下一个匹配记录 2. 通过less *.log | grep 'txt' 关键字查找 3. 通过F来开启实时监控head 命令head *.log 默认查看前10行日志head -n 20 *.log 查看前20行日志tail命令(常用)tail # 默认查看末尾几行的日志tail -n 10 *.log # 默认查看后10行日志tail -f *.log 实时监控日志ideaalt + 1 快速移动到上一个错误alt + 2 快速移动到下一个错误alt + enter 修改错误alt + control + o 删除多余jarcommand + option + L 格式化代码git//强制更新到本地git fetch -allgit reset --hard origin/master //远程分支名称git fetchgit remote -v # 查看远程仓库地址git remote set-url origin url # 修改原仓库地址git branch -r # 获取所有远程分支git chekout -b 本地分支名x origin/远程分支x # 拉取远程分支到本地分支并创建分支x，并切换到本地分支x 注：此方法会和远程分支建立映射关系git fetch origin 远程分支x:本地分支x # 使用此方法不会切换到改本地分支x，需要手动checkout。并且没有和远程有映射关系。git branch -vv # 查看本地分支和远程分支映射关系git branch -u origin/addFile || git branch --set-upstrean-to origin/addFile # 添加当前分支和远程分支关系git branch --unset-upstream # 撤销本地分支于远程分支映射关系git checkout -- readne.txt # 撤销本地单个文件git branch # 列出本地所有分支git chekcout name # 检出分支名，切换分支，本地文件不会改变git add dir # 提交目录git diff # 显示本地和暂存区的差异git diff --cached file # 显示暂存区和上一个commit的差异git diff HEAD # 显示工作区和单亲分支最新commit 之间差异git push origin 本地分支:远程分支 # 推送到远程git chekcout -f name # 强制切换分支， 会抛弃已修改的git branch -d name # 删除分支git stash list # 查询缓存列表git stash # 暂存起来git stash apply stash@&#123;0&#125; # 重新获取刚才变更git stash drop stash@&#123;0&#125; # 删除对应的名字git stash clear # 删除git log -p -2 # 查看最近提交的两次更新git push origin --delete [branch-name] # 删除远程分支brew 常用命令brew --version # 版本which brew # 安装路径brew install # 安装包brew search # 搜索brew update # 更新brew list # 列表brew info [] # 包信息brew deps [] # 包依赖brew server # web 服务brew -help # 帮助Mongoldbmongod # 启动服务mongo # 进入命令mongod --logpath /data/db/mongod.log # 设置日志位置show dbs # 查询所有数据列表db # 显示单亲数据库对象或集合use # 连接到指定的数据库db.runoob.insert(&#123;&#125;) # 插入数据runoob数据库名集合db.dropDatabase(); # 删除单亲数据库，默认test，db命令可以查看单亲数据库名mysql查询多个字段中任一个and CONCAT(IFNULL(a.problem,''),IFNULL(answers,'')) like '%制度%'node利用n进行升级sudo npm install -g n # 全局安装升级node工具包nsudo n stable # 安装最新稳定版noden # 显示已安装的noden latest # 安装最新版本noden lts # 安装最新长期维护版(LTS)noden &lt;version&gt; # 根据提供的版本号安装nodenpm升级npm install -g npm-check # 全局安装npm升级工具包npm-check -gu # 检查更新全局依赖包npm-check -u # 检查当前项目依赖npm config ls # 查询npm配置npm config set registry http://registry.npmjs.org/ # 全局切换官网镜像npm config set registry https://registry.npm.taobao.org # 全局切换到淘宝镜像# 发布模块$ npm publish [name]# 删除模块 $ npm unpublish [name]yarn 包管理器yarn init # 初始化项目yarn add [package] # 添加依赖yarn add [package]@[version]yarn add [package]@[tag]yarn upgrade [package] # 升级依赖yarn remove [package] # 移除依赖yarn install 或者yarn # 安装项目所有依赖","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"git","slug":"git","permalink":"//website.cwzcfj.cn/tags/git/"},{"name":"命令","slug":"命令","permalink":"//website.cwzcfj.cn/tags/命令/"}]},{"title":"kubenetes集群环境","slug":"kubenetes集群环境","date":"2019-04-17T13:59:27.000Z","updated":"2022-09-04T09:15:42.794Z","comments":false,"path":"2019/04/17/kubenetes集群环境/","link":"","permalink":"//website.cwzcfj.cn/2019/04/17/kubenetes集群环境/","excerpt":"","text":"Minikube 安装Minikube是一个快速搭建单节点kubeneter集群的工具123brew cask install minikube//查看系统版本minikube version kubectl 安装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# curl -LO https://stroage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/darwin/amd64/kubectl 安装最新版# chmod +x ./kubectl 赋二进制文件执行权限# sudo mv ./kubectl /usr/local/bin/kubectl 将二进制文件移到path中# kubectl versionminikube start //去创建k8s环境//执行结束可以通过kubectl cluster-info 查看集群信息 去连一下k8s api serverminikube ssh //进入虚拟机，进入集群，查看container运行起来了docker ps//退出，运行minikube dashboard # UI界面minikube delete # 删除已运行的Minikube实例minikube stop # 停止已运行的Minikube实例minikube logs # 查看日志//运行nginx# 运行一个nginx的pod, 然后导出运行的nginx服务kubectl run hello --image=nginx --port=80kubectl expose deployment hello --type=NodePort//命令minikube statusminikube docker-envkubectl get nodes # 显示本地节点kubectl get all # 显示所有资源 包括Pod, Service, Deployment, RS 等kubectl get all -o wide # 展示更多的信息, 包括镜像地址等kubectl get pod --all-namespaces //查看所有服务就绪(1) 命令行直接创建namespacekubectl create namespace new-namespace(2) 通过文件创建cat my-namespace.yamlapiVersion: v1kind: Namespacemetadata:name: new-namespacekubectl create -f ./my-namespace.yamlkubectl apply -fkubectl -n kub-system edit service kubernetes-dashboardkubectl delete -f kubernetes-dashboard.yaml//删除kubectl delete namespace new-namespace # 删除一个namespace会自动删除所有属于该namespace的资源，default和kube-system 命名空间不可删除。kubectl get pod # 显示所有podkubectl get serveice # 显示所有serverkubectl describe pods # 查看错误logkubectl get rc # 显示所有rckubectl delete rc rcname # 删除rckubectl delete service servicename # 删除serverkubectl delete pod podname # 删除pod 触发了replicas的确保机制，那么我们删除deployment deployment进行删除，则全部删除.kubectl delete deployment podnamekubectl delete pod -all # 删除所有启动clusterminikube startkubectl get pods --all-namespacekubectl get nodeseval $(minikube docker-env)1. 创建并启动minikube虚拟机$ minikube startStarting local Kubernetes cluster...Running pre-create checks...Creating machine...Starting local Kubernetes cluster...2. 创建 hello-minikube 部署$ kubectl run hello-minikube --image=tomcat:8.0 --port=8080deployment \"hello-minikube\" created3. 发布服务 hello-minikube$ kubectl expose deployment hello-minikube --type=NodePortservice \"hello-minikube\" exposed4. 查看 pods$ kubectl get podsNAME READY STATUS RESTARTS AGEhello-minikube-598805112-3bzmf 1/1 ContainerCreating 0 5s注意：刚开始时， pod 没有完全创建好的时候，状态是ContainerCreating, 当部署完成，状态就变成了Running.$ kubectl get podsNAME READY STATUS RESTARTS AGEhello-minikube-598805112-3bzmf 1/1 Running 0 25s用describe 可以查询失败的podkubectl describe pod hello-minikube-598805112-3bzmf5. 获取服务地址$ minikube service hello-minikube --urlhttp:xx.xx.xx.xx:30724$ minikube service hello-minikube 将直接打开地址到默认浏览器上。6. 停止minikube虚拟机$ minikube stop","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"//website.cwzcfj.cn/tags/环境搭建/"},{"name":"k8s","slug":"k8s","permalink":"//website.cwzcfj.cn/tags/k8s/"},{"name":"kubenetes","slug":"kubenetes","permalink":"//website.cwzcfj.cn/tags/kubenetes/"}]},{"title":"javaScript 正则表达式","slug":"js正则表达式","date":"2019-04-15T15:57:20.000Z","updated":"2022-09-04T09:22:00.652Z","comments":false,"path":"2019/04/15/js正则表达式/","link":"","permalink":"//website.cwzcfj.cn/2019/04/15/js正则表达式/","excerpt":"","text":"正则表达式规则 普通字符 字母、数字、汉子、下划线、以及没有特殊定义的标点符号，都是普通字符。 简单转义字符 采用前面加”/“的方法进行。 12345678910111213\\r, \\n 代表回车和换行符 \\t 制表符 \\/ 代表 \"/\" 本身 ^, $ 都有特殊意义，如果要想匹配字符串中 \"^\" 和 \"$\" 字符，则表达式就需要写成 \"\\^\" 和 \"\\$\"。 \\^ 匹配 ^ 符号本身 \\$ 匹配 $ 符号本身. 匹配小数点（.）本身 能够与 ‘多种字符’ 匹配的表达式 正则表达式中的一些表示方法，可以匹配’多种字符’其中的任意一个字符，比如”\\d”可以匹配任意一个数字。虽然可以匹配其中任意的字符，但是只能是一个，不是多个。 1234\\d 任意一个数字，0~9中的任意一个\\w 任意一个字母、数字、下划线，A~Z,a~z,0~9,_中的任意一个\\s 包含空格、制表符、换页符等空白字符的其中任意一个. 小数点可以匹配除换行符（/n）以外任意一个字符 自定义能够匹配’多种字符’的表达式 使用方括号[]包含一系列字符，能够匹配其中任意一个字符。[^]包含一系列，则能够匹配其中字符之外的任意一个字符。同样，虽然匹配但只匹配一个，不是多个。 1234[ab5@] 匹配\"a\"或\"b\"或\"5\"或\"@\"[^abc] 匹配\"a\",\"b\",\"c\"之外的任意一个字符[f-k] 匹配\"f\"~\"k\"之间的任意字母[^A-F0~3] 匹配\"A\"~\"F\",\"0\"~\"3\"之外的任意字符 修饰匹配次数的特殊符号 无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。 使用方法是：”次数修饰”放在”被修饰的表达式”后边。比如：”[bcd][bcd]” 可以写成 “[bcd]{2}”。 123456&#123;n&#125; 表达式重复n次，比如：\"\\w&#123;2&#125;\" 相当于 \"\\w\\w\"；\"a&#123;5&#125;\" 相当于 \"aaaaa\"&#123;m,n&#125; 表达式至少重复m次，最多重复n次，比如：\"ba&#123;1,3&#125;\"可以匹配 \"ba\"或\"baa\"或\"baaa\"&#123;m,&#125; 表达式至少重复m次，比如：\"\\w\\d&#123;2,&#125;\"可以匹配 \"a12\",\"_456\",\"M12344\"...? 匹配表达式0次或者1次，相当于 &#123;0,1&#125;，比如：\"a[cd]?\"可以匹配 \"a\",\"ac\",\"ad\"+ 表达式至少出现1次，相当于 &#123;1,&#125;，比如：\"a+b\"可以匹配 \"ab\",\"aab\",\"aaab\"...* 表达式不出现或出现任意次，相当于 &#123;0,&#125;，比如：\"\\^*b\"可以匹配 \"b\",\"^^^b\"... 其他一些代表抽象意义的特殊符号 一些符号在表达式中代表抽象的特殊意义： 123^ 字符开始的地方匹配，不匹配任何字符$ 字符串结束的地方匹配，不匹配任何字符\\b 匹配一个单词的边界，也就是单词和空格直接的位置，不匹配任何字符 一些符号可以影响表达式内部子表达式之间的关系： 12| 左右两边表达式直接\"或\"关系，匹配左边或者右边() 1.在被修饰匹配次数时，括号内的表达式可以作为整体被修饰 2.取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到 定义表达式 定义正则表达式有两种形式，一种是普通方式，一种是构造函数方式。 普通方式： var reg = /表达式/附加参数附加参数： 123g: 匹配全局i: 不区分大小写匹配m: 多行匹配 构造函数方式： var reg = new RegExp(“表达式”，”附加参数”)； ()、[]、{}区别 () 作用提取匹配的字符串，表达式中有几个()就会得到几个相应的匹配字符串.如(\\s+)表示连续的空格字符串 [] 定义范围.如[a-zA-Z0-9]表示要匹配英文字母和数字 {} 一般用来匹配长度.如\\d{3}表示3个空格，\\d[1,3]，匹配1-3个空格 ^和$ ^ 匹配一个字符串的开头，如(^a)就是a开头的字符串 $ 匹配一个字符串结尾，如(b$)以b为结尾的字符串 ^ 还有一个作用取反，如[^xyz]表示不包含xyz的字符","categories":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/tags/前端/"},{"name":"正则","slug":"正则","permalink":"//website.cwzcfj.cn/tags/正则/"},{"name":"js","slug":"js","permalink":"//website.cwzcfj.cn/tags/js/"}]},{"title":"H5 Audio 对象介绍","slug":"Audio","date":"2019-04-15T15:47:20.000Z","updated":"2022-09-04T09:24:41.801Z","comments":false,"path":"2019/04/15/Audio/","link":"","permalink":"//website.cwzcfj.cn/2019/04/15/Audio/","excerpt":"","text":"Audio 对象介绍详细AIP, 参w3school教程 创建Audio对象，可以通过下面两种方式得到。 12345678//方法一&lt;audio id=\"music\" src=\".map3\"&gt;Your browser does not support it&lt;/audio&gt;&lt;script&gt; var audio = document.getElementById('#music');&lt;/script&gt; //方法二var audio = new Audio('.map3'); 方法和属性介绍 1234567891011121314151617181920212223242526272829303132333435363738394041424344audio.play(); //开始播放audio.pause(); //暂停audio.autoPlay = true/false //设置播放状态console.log(audio.autoPlay); //获取播放状态audio.src //获取或者设置播放地址audio.volume = 0.5/1 //设置音量，最大为1,0为静音,获取音量console.log(audio.volume);audio.loop = true //设置或者获取循环状态console.log(audio.loop);audio.duration //获取音乐的长度，单位秒audio.currentTime //设置或者获取播放时间audio.ended //判断音乐是否播放完毕，只读属性事件playing当音乐开始播放，暂停后重新开始播放，设置currentTime后开始播放时触发audio.addEventListener('playing', function() &#123; console.log('playing');&#125;);pause当音乐暂停时和结束时触发audio.addEventListener('pause', function()&#123; console.log('pause');&#125;);ended当音乐结束时触发audio.addEventListener('ended', function() &#123; console.log('ended');&#125;);timeupdate//当currentTime更新时会触发timeupdate事件。 audio.ontimeupdate = function()&#123; console.log('timeupdate');&#125;volumechange当音量改变时触发audio.onvolumechange = function()&#123; console.log('volumechange')&#125;","categories":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/tags/前端/"},{"name":"h5","slug":"h5","permalink":"//website.cwzcfj.cn/tags/h5/"},{"name":"audio","slug":"audio","permalink":"//website.cwzcfj.cn/tags/audio/"}]},{"title":"Centos 笔记","slug":"centos笔记","date":"2019-04-15T15:37:40.000Z","updated":"2022-09-04T09:26:45.059Z","comments":false,"path":"2019/04/15/centos笔记/","link":"","permalink":"//website.cwzcfj.cn/2019/04/15/centos笔记/","excerpt":"","text":"Centos使用笔记Centos6忘记密码解决办法，root和普通用户均可?参考地址: http://www.cnblogs.com/ljmjjy0820/p/6129893.html 连接ssh 12345678910111213输入命令：rpm -qa | grep ssh注：若没安装SSH则可输入：yum install openssh-server安装启动SSH服务输入命令：service sshd restart 重启SSH服务。 命令：service sshd start 启动服务 | 命令：service sshd stop 停止服务 重启后可输入：netstat -antp | grep sshd 查看是否启动22端口（可略）如何设置SSH服务为开机启动？输入命令：chkconfig sshd on 即可。注：若是chkconfig sshd off则禁止SSH开机启动。 在安装完CentOS6.5以后,通过ifconfig来查看IP来使用putty软件来实现远程链接,但发现没有eth0,只有l0？ 解决参考：http://www.linuxidc.com/Linux/2015-01/111265.htm 查询\\安装SSH服务1234567891011121314151617181920212223#rpm -qa |grep ssh 检查是否装了SSH包#yum install openssh-server 没有的话，安装SSH服务#chkconfig --list sshd 检查SSHD是否在本运行级别下设置为开机启动#chkconfig --level 2345 sshd on 如果没设置启动就设置下#service sshd restart 重新启动SSHD#netstat -antp |grep sshd 看看是否启动了22端口，需要确认下#iptables -nL 看看是否放行了22口#iptables -I INPUT -p tcp --dport 22 -j ACCEPT 没有的话放行22端口#iptables save 保存防火墙规则# vi /etc/ssh/sshd_config 用vi打开SSH的配置文件，在这里我们先保持默认（允许普通用户通过口令登录）#useradd lhc 添加普通用户（lhc）#passwd lhc 修改lhc密码 3.centos ping不通外网域名，能ping通地址？1234567891011121314151617181920212223242526272829主机名配置假如要设置主机名为：centos1.修改network vi /etc/sysconfig/networkHOSTNAME=centos:x #保存退出2.VM虚拟网络，采用桥接模式3.vim /etc/sysconfig/network-scripts/ifcfg-eth0配置好对应的ip，GETWAY，HOSTNAME，DSN1等参数，如下所示：BOOTPROTO=static #启用静态ip地址ONBOOT=yes #开启自动启用网络连接IPADDR=192.168.79.129 #设置ip地址NETMASK=255.255.255.0 #设置子网掩码GATEWAY=192.168.79.2 #设置网关DNS1=8.8.8.8 #设置主DNSDNS2=8.8.4.4 #设置备DNSIPV6INIT=no #禁用ipv6HWADDR=00:0C:29:A9:91:42service ip6tables stop #停止IPV6服务chkconfig ip6tables off #禁止ipv6开机启动//重启networkservice netwrok restart4.检查虚拟机里面网络编辑Ant配置，是否和对应本地配置匹配。这里就不截图了。 4.常用的命令 地址: http://www.cnblogs.com/wangpd/p/6876825.html123yum命令安装epel是社区强烈打造的免费开源发行软件包版本库。yum install epel-release -y yum命令 地址: http://man.linuxde.net/yum centos71234567891011121314151617181920212223242526272829303132333435查询是否自启动systemctl list-unit-files查询所有已启动服务 systemctl list-units --type=service使某服务自动启动systemctl enable httpd.service使某服务不自动启动 systemctl disable httpd.service启动某服务systemctl start httpd.service停止某服务systemctl stop httpd.service重启某服务systemctl restart httpd.serviceTCP listen# ss -ltUDP listen# ss -ulTCP连线# ss -t//查看端口使用情况ss -tlnss -a 查看所有服务端口 centos firewalld简单使用 http://blog.csdn.net/y534560449/article/details/65626183 centos PHP环境搭建 http://www.cnblogs.com/zhaosiwen/p/5157757.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//查看安装的模块php -mphp -i | grep php.ini#apache主配置文件/etc/httpd/conf/httpd.conf#相关配置 比如vhost文件就可以创建在该目录下/etc/httpd/conf.d/#模块配置文件 比如你要开启rewrite模块，可能你就需要到这个目录下面做一些配置了/etc/httpd/conf.modules.d/#web可访问目录 网站根目录/var/www/html#apache日志文件目录/var/log/httpd///查看php包 rpm -qa | grep phprpm -qa |grep -i mysql//删除包yum remove php//查询是否有残留目录whereis php//删除查看的php包rpm -e *//安装php需要先添加EPEL 包的仓库源yum -y install epel-release//安装nginxyum -y install nginx//查看源目录cd /etc/yum.repos.dls//清除缓存yum clean all//重新生成缓存yum makecache1.安装yum -y install mariadb*2.开启MySQL服务systemctl start mariadb.service3.设置开机启动MySQL服务systemctl enable mariadb.service4.设置root帐户的密码mysql_secure_installation//php7-fpm 添加另外一个仓库//PHP7-FPM webtatic 仓库：rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpmyum -y install php70w-fpm php70w-cli php70w-gd php70w-mcrypt php70w-mysql php70w-pear php70w-xml php70w-mbstring php70w-pdo php70w-json php70w-pecl-apcu php70w-pecl-apcu-develapache启动systemctl start httpd停止systemctl stop httpd重启systemctl restart httpdmysql启动systemctl start mysqld停止systemctl stop mysqld重启systemctl restart mysqldphp-fpm启动systemctl start php-fpm停止systemctl stop php-fpm重启systemctl restart php-fpmnginx启动systemctl start nginx停止systemctl stop nginx重启systemctl restart nginx http://www.jianshu.com/p/999949f8fbf3 1234567891011121314查看所有打开的端口： firewall-cmd --zone=public --list-ports更新防火墙规则： firewall-cmd --reload添加firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent永久生效，没有此参数重启后失效）删除firewall-cmd --zone= public --remove-port=80/tcp --permanentfirewall-cmd --permanent --zone=public --add-port=3306/tcpfirewall-cmd --permanent --zone=public --add-port=3306/udp这样就开放了相应的端口。执行firewall-cmd --reload mysql文章 http://blog.csdn.net/gebitan505/article/details/54613549 centos7重置密码。http://blog.csdn.net/keepd/article/details/77151006 mysql:121.用户名和密码： root root2.远程连接用户名和密码： admin admin 添加用户名和密码方法：http://www.cnblogs.com/chenggege/p/7761255.html 123456789101112131415161718192021222324mysql 语法：show databases; //查询所有dbuse db; //选中要操作的数据库create table tableName ( id number, bookName varchar(20), price varchar(20)); //创建表select * from tableName; //查询所有信息slecet * from tableName where type=xxx; //根据条件查询所有信息update tableName set type='xxx' where name=\"shuigu\";//根据条件更新某条数据delete from tableName where name='xxx' //删除单条数据 DROP DATABASE 库名; //删除db数据库 DROP TABLE 表名； //删除表DELETE FROM 表名; //清空表","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/tags/工具/"},{"name":"centos7","slug":"centos7","permalink":"//website.cwzcfj.cn/tags/centos7/"},{"name":"环境搭建","slug":"环境搭建","permalink":"//website.cwzcfj.cn/tags/环境搭建/"}]},{"title":"curl常用命令","slug":"curl命令","date":"2019-04-15T15:31:23.000Z","updated":"2022-09-04T09:35:28.789Z","comments":false,"path":"2019/04/15/curl命令/","link":"","permalink":"//website.cwzcfj.cn/2019/04/15/curl命令/","excerpt":"","text":"curl使用常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354curl -o/O pathName url //下载文件o下载到本地并命名pathName O默认url 如下： # 将文件下载到本地并命名为mygettext.htmlcurl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html# 将文件保存到本地并命名为gettext.html curl -O http://www.gnu.org/software/gettext/manual/gettext.html curl -O URL1 -O URL2 //同时获取多个断点续传，通过使用-C选项可对大文件使用断点续传功能# 当文件在下载完成之前结束该进程 $ curl -O http://www.gnu.org/software/ gettext/manual/gettext.html ############## 20.1%Head请求：curl -l http://www.mzwu.com/ -IGET请求：curl -l http://www.mzwu.com/?domain=mzwu.comcurl example.com/form.cgi?data=xxxGET方法相对简单，只要把数据附在网址后面就行POST请求：curl -l http://www.mzwu.com/ -d \"domain=mzwu.com\"POST方法必须把数据和网址分开，curl就要用到--data参数。curl -X POST --data \"data=xxx\" example.com/form.cgi如果你的数据没有经过表单编码，还可以让curl为你编码，参数是`--data-urlencode`。curl -X POST--data-urlencode \"date=April 1\" example.com/form.cgicurl默认的HTTP动词是GET，使用`-X`参数可以支持其他动词。curl -X POST www.example.comcurl -X DELETE www.example.com添加HTTP头：curl -l http://www.mzwu.com/ -H \"name:dnawo\" -H \"sex:boy\"伪造referer：curl -l http://www.mzwu.com/ -e \"http://www.baidu.com/\"Referer字段有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。curl --referer http://www.example.com http://www.example.comcurl -v url //打印更多信息，包括发送的请求信息，这在调试脚本是特别有用,`-v`参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。http request之中，自行增加一个头信息。`--header`参数就可以起到这个作用curl --header \"Content-Type:application/json\" http://example.com网域需要HTTP认证，这时curl需要用到`--user`参数curl --user name:password example.com可以显示更详细的通信过程curl --trace output.txt www.sina.com 或者curl --trace-ascii output.txt www.sina.com curl -I url //查看响应头curl -i url //`-i`参数可以显示http response的头信息，连同网页代码一起。`-I`参数则是只显示http response的头信息。","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/tags/工具/"},{"name":"curl","slug":"curl","permalink":"//website.cwzcfj.cn/tags/curl/"}]},{"title":"git配置用户密码","slug":"git配置","date":"2019-04-15T15:28:34.000Z","updated":"2022-09-04T09:32:18.124Z","comments":false,"path":"2019/04/15/git配置/","link":"","permalink":"//website.cwzcfj.cn/2019/04/15/git配置/","excerpt":"","text":"TortoiseGit 远程上传push代码，配置不用每次输入用户名和密码方法 配置方法： 打开目录C:\\Documents and Settings\\Administrator\\，找到.gitconfig文件，里面已经存在你已经配置好的name和email,只需在下面加人一行12[credential] helper = store 下次只需在输入一次用户名和密码，git就会记住，而在目录C:\\Documents and Settings\\Administrator\\目录下，有.git-credentials文件，里面就保存你的用户名和密码(注意是明文) 这样以后再链接时，就不需要输入用户名和密码.","categories":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"//website.cwzcfj.cn/tags/工具/"},{"name":"git","slug":"git","permalink":"//website.cwzcfj.cn/tags/git/"}]},{"title":"javaScript基础知识","slug":"javascript","date":"2019-04-15T14:26:20.000Z","updated":"2022-09-04T09:35:32.446Z","comments":false,"path":"2019/04/15/javascript/","link":"","permalink":"//website.cwzcfj.cn/2019/04/15/javascript/","excerpt":"","text":"js基础知识点 js面向对象 面向对象编程（OOP）的特点: 抽象： 抓住核心问题 封装： 只能通过对象来访问方法 继承： 从已有的对象下继承新的对象 多态： 多对象的不同的形态 面向对象是一种编程思想，把业务中看作对象，对象拥有属性和方法，对一下业务进行封装，方便维护。javaScript面向对象是通过prototype的方式来实现编程的。 js面向对象创建的几种方式或者实现? 工厂模式创建对象： 面向对象中的封装函数(内置对象)就是一个函数，然后放入参数，返回对象，流水线工作 1234567891011function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.getName = function () &#123; return this.name; &#125; return o;&#125;var person = createPerson('Jack', 19, 'SoftWare Engineer'); 创建对象对象交给工厂方法来实现，可以传递参数，但缺点是无法识别对象类型，因为创建对象是使用Object的原生构造函数来完成的。 构造函数模式 12345678910 function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.getName = function() &#123; return this.name; &#125;&#125;var person1 = new Person(\"Jack\", 19, 'SoftWare Engineer');var person2 = new Person(\"Liye\", 23, 'Mechanical Engineer'); 自定义的构造函数，（与普通函数一样，只是用它来创建对象），对象类型的属性和方法。它区别与工厂模式： 没有显示地创建对象 直接将属性和方法赋值给this对象 没有return语句 上述中person1,person2都是person的实例，因此可以用instanceof判断 1234alert(person1 instanceof Person);//true;alert(person2 instanceof Person);//true;alert(person1 instanceof Object);//true;alert(person1.constructor === person2.constructor);//ture; 虽然构造函数方式比较不错，但是也存在缺点，那就是在创建对象时，特别针对对象属性指向的函数时，会重复创建函数实例，以上述代码为基础，可以改成： 12345678function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.getName = new Function () &#123;//改写后效果与原代码相同，不过是为了方便理解 return this.name; &#125;&#125; 上述代码，创建多个实例时，会重复调用new Function();创建多个函数实例，这些函数实例还不是一个作用域中，当然这一般不会有错，但这会造成内存浪费。当然，可以在函数中定义一个getName = getName的引用，而getName函数在Person外定义，这样可以解决重复创建函数实例问题，但在效果上并没有起到封装的效果，如下所示： 123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.getName = getName;&#125;function getName() &#123;//到处是代码，看着乱！！ return this.name;&#125; 原型模式 js每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，它是通过new操作符使用函数创建的实例的原型对象，原型对象最大的特点是，所有对象实例共享它所包含的属性和方法，也就是说，所有在原型对象中创建的属性和方法都直接被所有对象实例共享。 1234567891011function Person()&#123;&#125;Person.prototype.name = 'Jack';//使用原型来添加属性Person.prototype.age = 29;Person.prototype.getName = function()&#123; return this.name;&#125;var person1 = new Person();alert(person1.getName());//Jackvar person2 = new Person();alert(person1.getName === person2.getName);//true;共享一个原型对象的方法 原型与in操作符 一句话：无论原型中属性，还是对象实例的属性，都可以使用in操作符访问到；要想判断是否是实例本身的属性可以使用object.hasOwnProperty(‘attr’)来判断；原型模式的缺点，它省略了为构造函数传递初始化参数，这在一定程序带来不便；另外，最主要是当对象的属性是引用类型时，它的值是不变的，总是引用同一个外部对象，所有实例对该对象的操作都会其它实例：12345678function Person() &#123;&#125;Person.prototype.name = 'Jack';Person.prototype.lessons = ['Math','Physics'];var person1 = new Person();person1.lessons.push('Biology');var person2 = new Person();alert(person2.lessons);//Math,Physics,Biology，person1修改影响了person2 组合构造函数及原型模式 目前最为常用的定义类型方式，是组合构造函数模式与原型模式。构造函数模式用于定义实例的属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方方法的引用，最大限度的节约内存。此外，组合模式还支持向构造函数传递参数，可谓是集两家之所长。 123456789101112131415161718function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.lessons = ['Math', 'Physics'];&#125;Person.prototype = &#123; constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person getName: function () &#123; return this.name; &#125;&#125;var person1 = new Person('Jack', 19, 'SoftWare Engneer');person1.lessons.push('Biology');var person2 = new Person('Lily', 39, 'Mechanical Engneer');alert(person1.lessons);//Math,Physics,Biologyalert(person2.lessons);//Math,Physicsalert(person1.getName === person2.getName);//true,//共享原型中定义方法 在所接触的JS库中，jQuery类型的封装就是使用组合模式来实例的 动态原型模式 组合模式中实例属性与共享方法（由原型定义）是分离的，这与纯面向对象语言不太一致；动态原型模式将所有构造信息都封装在构造函数中，又保持了组合的优点。其原理就是通过判断构造函数的原型中是否已经定义了共享的方法或属性，如果没有则定义，否则不再执行定义过程。该方式只原型上方法或属性只定义一次，且将所有构造过程都封装在构造函数中，对原型所做的修改能立即体现所有实例中： 1234567891011121314151617181920function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.lessons = ['Math', 'Physics'];&#125;if (typeof this.getName != 'function') &#123;//通过判断实例封装 Person.prototype = &#123; constructor: Person,//原型字面量方式会将对象的constructor变为Object，此外强制指回Person getName: function () &#123; return this.name; &#125; &#125;&#125;var person1 = new Person('Jack', 19, 'SoftWare Engneer');person1.lessons.push('Biology');var person2 = new Person('Lily', 39, 'Mechanical Engneer');alert(person1.lessons);//Math,Physics,Biologyalert(person2.lessons);//Math,Physicsalert(person1.getName === person2.getName);//true,//共享原型中定义方法 常用 123456789101112131415161718192021Object.prototype.toString.call();用来判断对象的类型。toLowerCase(); 转小写toUpperCase(); 转大写str.charAt(index)； //根据index索引获取字符串 Math.random(); //获取随机数（包含0到1不包含1）//生成整数,如生成20以下整数（0-19） 利用floor向下取整Math.floor(Math.random()*20);//获取某个值之间的随机数Math.floor(Math.random() * (max - min + 1)) + min；Math.max(x,y); //返回最大值Math.min(x,y); //返回最小值Math.round(x); //四舍五入Math.floor(); //向下舍入Math.abs(); //返回绝对值transformrotate(deg)skew(x,y)scale(x,y)translate(x,y) js继承 继承方式： 1、拷贝继承：通用型 有new无new都可以用 2、类式继承：new构造函数—利用构造函数（类）继承的方式 3、原型继承：无new的对象—借助原型来实现对象继承对象 属性继承：调用父类的构造函数call 方法继承：用for in的形式 拷贝继承（jq也用拷贝继承）123456789101112131415161718192021222324252627282930313233343536373839var a = &#123; name: '小米' &#125;; //拷贝继承 function extend(obj1, obj2) &#123; for (var attr in obj2) &#123; obj1[attr] = obj2[attr]; &#125; &#125; //原型继承 var b=cloneObj(a); b.name='小乔'; alert(a.name); alert(b.name); function cloneObj(obj) &#123; var F=function () &#123;&#125;; F.prototype=obj; return new F(); &#125; //类式继承 function A() &#123;//父类 this.name='小米'; &#125; A.prototype.showName=function () &#123; alert(this.name); &#125; function B() &#123;//子类 A.call(this);//属性和方法分开继承 &#125; //B.prototype=new A();//一句话实现继承，但会有很多问题，比如指向问题，属性会互相影响 //类式继承改进：至少由以下四句实现方法的继承，属性需要分开继承 var F=function () &#123;&#125;; F.prototype=A.prototype; B.prototype=new F(); B.prototype.constructor=A;//修正指向问题 var b1=new B(); b1.name='笑笑'; b1.showName(); js闭包 闭包就是一个函数引用另外一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会徒增内存消耗！执行环境、作用域链、垃圾回收机制、函数嵌套 事件委托的优点和缺点 优点： 减少事件注册，节省内存。比如：table代理所有的td的click.在ul上代理所有li的click事件。 简化了dom节点更新时，相应事件的更新。 缺点： 事件委托基于冒泡，对应不冒泡的不支持。 层级过多，冒泡过程中，可能被某层阻止掉。 把所有的事件都用代理可能会出现事件误判。 ES6语法 一. 块级作用域绑定 (1). let声明 使用let声明变量的语法和使用var声明的语法是一样的。但是let声明的变量的作用域会限制在当前的代码块中。这是let与var的最大区别。用 let 声明的变量具有块级作用域，只能在声明的块中访问，在块外面无法访问 (2). const声明 ES6 使用const来声明的变量称之为常量。这意味着它们不能再次被赋值,所有的 const 声明的变量都必须在声明处初始化 二. 函数新增特性 (1). 带默认参数的函数 1234 function makeRequest(url, timeout, callback) &#123; timeout = timeout || 2000; callback = callback || function() &#123;&#125;;&#125; 一般在函数内部需要做一些默认值的处理，有个bug，timeout是0的时候也会当做假值来处理，从而给赋值默认值2000. ES6从语言层面面上增加了 默认值的 支持这个函数如果只传入第一个参数，后面两个不传入，则会使用默认值。如果后面两个也传入了参数，则不会使用默认值。123function makeRequest(url, timeout = 2000, callback = function() &#123;&#125;) &#123; // 其余代码 &#125; (2). 默认参数对 arguments 对象的影响 ES6参数默认值的时候，不管是否是在严格模式下，都和ES5的严格模式相同。123456789101112&lt;script type=\"text/javascript\"&gt; function foo(a, b = 30) &#123; console.log(arguments[0] === a); //true console.log(arguments[1] === b); //true a = 10; b = 20; console.log(arguments[0] === a); //false。 由于b使用了默认值。虽然a没有使用默认值，但是仍然表现的和严格模式一样。 console.log(arguments[1] === b); //false。 b使用了默认值，所以表现的和严格模式一样。 &#125; foo(1, 2);&lt;/script&gt; (3).默认参数表达式 参数的默认值，也可以是一个表达式或者函数调用等123456789101112&lt;script type=\"text/javascript\"&gt; function getValue() &#123; return 5; &#125; function add(first, second = getValue()) &#123; //表示使用getValue这个函数的返回值作为second的默认值。 return first + second; &#125; console.log(add(1, 1)); // 2. 调用add函数的时候，传入了第二个参数，则以传入的参数为准。 console.log(add(1)); // 6。 调用add函数的时候，没有传入第二个参数，则会调用getValue函数。&lt;/script&gt; getValue()只会在调用add且不传入第二个参数的时候才会去调用。不是在解析阶段调用的。 （4）. 未命名参数问题 Javascript并不限制传入的参数的数量, 在ES5之前，我们一般可以通过arguments对象来获取到未命名参数的值。但是罗显繁琐1234567&lt;script type=\"text/javascript\"&gt; function foo(a) &#123; console.log(a); console.log(arguments[1]) //取得传入的多余的参数。 &#125; foo(2, 3);&lt;/script&gt; ES6，提供了一种更加优雅处理未命名参数的问题：剩余参数(Rest Parameters) 语法：function a(a, … b){ } 剩余参数使用三个点( … )和变量名来表示。 (5). 函数中的扩展运算符 Math中的max函数可以返回任意多个参数中的最大值。但是如果这些参数在一个数组中，则没有办法直接传入。以前通用的做法是使用applay方法.1234&lt;script type=\"text/javascript\"&gt; let values = [25, 50, 75, 100] console.log(Math.max.apply(Math, values)); // 100&lt;/script&gt; 这种方法虽然可行，但是总是不是那么直观.ES6提供的扩展运算符可以很容易的解决这个问题。在数组前加前缀 … (三个点)12345&lt;script type=\"text/javascript\"&gt; let values = [25, 50, 75, 100] console.log(Math.max(...values)); //使用扩展运算符。相当于拆解了数组了。 console.log(Math.max(...values, 200)); //也可以使用扩展运算符和参数的混用，则这个时候就有 5 个数参与比较了。&lt;/script&gt; 三. 全新的函数：箭头函数（=&gt;） 箭头函数可以赋值给变量，也可以像匿名函数一样直接作为参数传递1234567891011&lt;script type=\"text/javascript\"&gt; var sum = (num1, num2) =&gt;&#123; return num1 + num2; &#125; console.log(sum(3, 4)); //前面的箭头函数等同于下面的传统函数 var add = function (num1, num2) &#123; return num1 + num2; &#125; console.log(add(2, 4))&lt;/script&gt; 如果函数体内只有一行代码，则包裹函数体的 大括号 ({ })完全可以省略。如果有return，return关键字也可以省略。 如果函数体内有多条语句，则 {} 不能省略。12345678910111213&lt;script type=\"text/javascript\"&gt; var sum = (num1, num2) =&gt; num1 + num2; console.log(sum(5, 4)); //前面的箭头函数等同于下面的传统函数 var add = function (num1, num2) &#123; return num1 + num2; &#125; console.log(add(2, 4)); //如果这一行代码是没有返回值的，则方法的返回自也是undefined var foo = (num1, num2) =&gt; console.log(\"aaa\"); console.log(foo(3,4)); //这个地方的返回值就是undefined &lt;/script&gt; 如果箭头函数只有一个参数，则包裹参数的小括号可以省略。其余情况下都不可以省略。当然如果不传入参数也不可以省略1234&lt;script type=\"text/javascript\"&gt; var foo = a=&gt; a+3; //因为只有一个参数，所以()可以省略 console.log(foo(4)); // 7&lt;/script&gt; 如果想直接返回一个js对象，而且还不想添加传统的大括号和return，则必须给整个对象添加一个小括号 ()1234567891011&lt;script type=\"text/javascript\"&gt; var foo = ()=&gt;(&#123;name:\"lisi\", age:30&#125;); console.log(foo()); //等同于下面的； var foo1 = ()=&gt;&#123; return &#123; name:\"lisi\", age : 30 &#125;; &#125;&lt;/script&gt; 使用箭头函数实现函数自执行12345678910&lt;script type=\"text/javascript\"&gt; var person = (name =&gt; &#123; return &#123; name: name, age: 30 &#125; &#125; )(\"zs\"); console.log(person);&lt;/script&gt; 箭头函数中无this绑定 四. 对象功能的扩展 (1) 简写的属性初始化,ES6中简化成如下的形式:12345678910&lt;script type=\"text/javascript\"&gt; function createPerson(name, age) &#123; //返回一个对象：属性名和参数名相同。 return &#123; name, //当对象属性名和本地变量名相同时，可以省略冒号和值 age &#125; &#125; console.log(createPerson(\"lisi\", 30)); // &#123;name:\"lisi\", age:30&#125;&lt;/script&gt; (2) 简写的方法声明123456789&lt;script type=\"text/javascript\"&gt; var person = &#123; name:'李四', sayHell() &#123; console.log(\"我的名字是：\" + this.name); &#125; &#125; person.sayHell()&lt;/script&gt; 省略了冒号和function看起来更简洁 (3) 在字面量中动态计算属性名 在ES5之前，如果属性名是个变量或者需要动态计算，则只能通过 对象.[变量名] 的方式去访问。而且这种动态计算属性名的方式 在字面量中 是无法使用的.12345678&lt;script type=\"text/javascript\"&gt; var p = &#123; name : '李四', age : 20 &#125; var attName = 'name'; console.log(p[attName]) //这里 attName表示的是一个变量名。&lt;/script&gt; 在ES6中，把属性名用[ ]括起来，则括号中就可以引用提前定义的变量。12345678&lt;script type=\"text/javascript\"&gt; var attName = 'name'; var p = &#123; [attName] : '李四', // 引用了变量attName。相当于添加了一个属性名为name的属性 age : 20 &#125; console.log(p[attName]) // 李四&lt;/script&gt; (4)新增的方法 Object.is(); 使用比较操作符（==）或严格比较操作符（===）.许多开发者为了避免在比较的过程中发生强制类型转换，更倾向于后者。但即使是严格等于操作符，它也不是万能的。例如，它认为 +0 和 -0 是相等的，虽然它们在 JavaScript 引擎中表示的方式不同。同样 NaN === NaN 会返回 false，所以必须使用 isNaN() 函数才能判断 NaN 。 ECMAScript 6 引入了 Object.is() 方法来补偿严格等于操作符怪异行为的过失。该函数接受两个参数并在它们相等的返回 true 。只有两者在类型和值都相同的情况下才会判为相等。如下所示：1234567891011121314console.log(+0 == -0); // trueconsole.log(+0 === -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(NaN == NaN); // falseconsole.log(NaN === NaN); // falseconsole.log(Object.is(NaN, NaN)); // trueconsole.log(5 == 5); // trueconsole.log(5 == \"5\"); // trueconsole.log(5 === 5); // trueconsole.log(5 === \"5\"); // falseconsole.log(Object.is(5, 5)); // trueconsole.log(Object.is(5, \"5\")); // false Object.is() 的表现和 === 是相同的。它们之间的区别是前者 认为 +0 和 -0 不相等而 NaN 和 NaN 则是相同的。不过弃用后者是完全没有必要的。何时选择 Object.is() 与 == 或 === 取决于代码的实际情况 Object.assign() assing可以把一个对象的属性和访问完整的转copy到另外一个对象中。1234567891011121314&lt;script type=\"text/javascript\"&gt; var p = &#123; name : \"lisi\", age : 20, friends : ['张三', '李四'] &#125; var p1 = &#123;&#125;; Object.assign(p1, p); //则p1中就有了与p相同的属性和方法. p1是接受者，p是提供者 console.log(p1); //这种copy是浅copy，也就是说如果属性值是对象的话，只是copy的对象的地址值(引用） console.log(p1.friends == p.friends); //true p1和p的friends同事指向了同一个数组。 p.friends.push(\"王五\"); console.log(p1.friends); //['张三', '李四', '王五']&lt;/script&gt; assign方法可以接受任意多的提供者。意味着后面提供者的同名属性和覆盖前面提供者的属性值12345678910111213&lt;script type=\"text/javascript\"&gt; var p = &#123; name : \"lisi\", age : 20, friends : ['张三', '李四'] &#125; var p1 = &#123; name : 'zs', &#125; var p2 = &#123;&#125;; Object.assign(p2, p, p1); //p和p1都是提供者 console.log(p2.name); // zs&lt;/script&gt; 五. 字符串功能的增强 (1) 查找子字符串 在以前在字符串中查找字符串的时候，都是使用indexOf方法.ES6新增了三个方法来查找字符串。12345678910111213141516includes() 方法会在给定文本存在于字符串中的任意位置时返回 true，否则返回 false 。startsWith() 方法会在给定文本出现在字符串开头时返回 true，否则返回 false 。endsWith() 方法会在给定文本出现在字符串末尾时返回 true，否则返回 false 。var msg = \"Hello world!\"; console.log(msg.startsWith(\"Hello\")); // trueconsole.log(msg.endsWith(\"!\")); // trueconsole.log(msg.includes(\"o\")); // trueconsole.log(msg.startsWith(\"o\")); // falseconsole.log(msg.endsWith(\"world!\")); // trueconsole.log(msg.includes(\"x\")); // falseconsole.log(msg.startsWith(\"o\", 4)); // trueconsole.log(msg.endsWith(\"o\", 8)); // trueconsole.log(msg.includes(\"o\", 8)); // false (2) repeat方法 ECMAScript 6 还向字符串添加了 repeat() 方法，它接受一个数字参数作为字符串的重复次数。该方法返回一个重复包含初始字符串的新字符串，重复次数等于参数.123console.log(\"x\".repeat(3)); // \"xxx\"console.log(\"hello\".repeat(2)); // \"hellohello\"console.log(\"abc\".repeat(4)); // \"abcabcabcabc\" (3) 字符串模板字面量 基本语法,使用一对反引号 “(tab正上方的按键)来表示模板字面量.12345let message = `Hello world!`; //使用模板字面量创建了一个字符串console.log(message); // \"Hello world!\"console.log(typeof message); // \"string\"console.log(message.length); // 12 注意：如果模板字符串中使用到了反引号，则应该转义。但是单双引号不需要转义 (4) 多行字符串 ES6中字符串的模板字面量轻松的解决了多行字符串的问题，而且没有任何新的语法.1234567&lt;script type=\"text/javascript\"&gt; var s = `abc aaaaa dsalfja dfadfja`; console.log(s);&lt;/script&gt; 但是要注意： 反引号中的所有空格和缩进都是有效字符。 (5) 字符串置换 置换允许你将 JavaScript 表达式嵌入到模板字面量中并将其结果作为输出字符串中的一部分。 语法：${变量名、表达式、任意运算、方法调用等} 可以嵌入任何有效的JavaScript代码.12345&lt;script type=\"text/javascript\"&gt; var name = \"李四\"; var msg = `欢迎你$&#123;name&#125;同学`; console.log(msg)&lt;/script&gt; (6) 模板标签 什么是模板标签,模板字面量真正的强大之处来源于模板标签。一个模板标签可以被转换为模板字面量并作为最终值返回。标签在模板的头部，即左 ` 字符之前指定，如下所示：1let message = myTag`Hello world`; 在上面的代码中，myTag就是模板标签。 myTag其实是一个函数，这个函数会被调用来处理这个模板字符串。 (7) 定义模板标签 一个标签仅代表一个函数，他接受需要处理的模板字面量。标签分别接收模板字面量中的片段，且必须将它们组合以得出结果。函数的首个参数为包含普通 JavaScript 字符串的数组。余下的参数为每次置换的对应值。 标签函数一般使用剩余参数来定义，以便轻松地处理数据。如下：123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; let name = '张三', age = 20, message = show`我来给大家介绍$&#123;name&#125;的年龄是$&#123;age&#125;.`; /* 应该定义一个函数show： 参数1：一个字符串数组。在本例中包含三个元素。 0:\"我来给大家介绍\" 1:\"的年龄是\" 2:\".\" 参数2和参数3：表示需要置换的字符串的值。 */ function show(stringArr, value1, value2) &#123; console.log(stringArr); // console.log(value1); // 张三 console.log(value2); // 20 return \"abc\"; &#125; console.log(message); //abc&lt;/script&gt; 为了简化书写，一般把Value1和Value2写成剩余字符串的形式123function show(stringArr, ...values)&#123;&#125; 五. 解构 (1) 解构的实用性 ECMAScript 5 或更早的版本中，从对象或数组中获取特定的数据并赋值给本地变量需要书写很多并且相似的代码。例如：123456789let options = &#123; repeat: true, save: false &#125;; // 从对象中提取数据 let repeat = options.repeat, save = options.save; 对象解构的基本形式123456789let node = &#123; type: \"Identifier\", name: \"foo\" &#125;;//这里就相当于声明了两个变量： type = node.type; name:node.namelet &#123; type, name &#125; = node;console.log(type); // \"Identifier\"console.log(name); // \"foo\" 在上面的结构中必须要初始化。否则会出现语法错误12345678// 语法错误！var &#123; type, name &#125;;// 语法错误！let &#123; type, name &#125;;// 语法错误！const &#123; type, name &#125;; (2) 解构赋值表达式 声明的变量想改变他们的值，也可以使用解构表达式.1234567891011121314&lt;script type=\"text/javascript\"&gt; let node = &#123; type: \"Identifier\", name: \"foo\" &#125;, type = \"Literal\", name = 5; //注意：此处必须要在圆括号内才能使用解构表达式 (&#123;type, name&#125; = node); console.log(type); // \"Identifier\" console.log(name); // \"foo\"\"&lt;/script&gt; (3) 对象解构时的默认值 如果赋值号右边的对象中没有与左边变量同名的属性，则左边的变量会是 undefined12345678910let node = &#123; type: \"Identifier\", name: \"foo\" &#125;;//因为node中没有叫value的属性，所以valued的值将会是undefinedlet &#123; type, name, value &#125; = node;console.log(type); // \"Identifier\"console.log(name); // \"foo\"console.log(value); // undefined 手动指定他的默认值123456789101112&lt;script type=\"text/javascript\"&gt; let node = &#123; type: \"Identifier\", name: \"foo\" &#125;; //手动添加value的默认值为3 let &#123; type, name, value = 3&#125; = node; console.log(type); // \"Identifier\" console.log(name); // \"foo\" console.log(value); // 3&lt;/script&gt; 赋值给不同的变量名1234567891011&lt;script type=\"text/javascript\"&gt; let node = &#123; type: \"Identifier\", name: \"foo\" &#125;; // localType才是要定义的新的变量。 type是node的属性 let &#123;type: localType, name: localName&#125; = node; console.log(localType); // \"Identifier\" console.log(localName); // \"foo\"&lt;/script&gt; 注意：冒号后面才是要定义的新的变量，这个可以我们的对象字面量不太一样！这个地方也可以使用默认值12345678let node = &#123; type: \"Identifier\" &#125;;let &#123; type: localType, name: localName = \"bar\" &#125; = node;console.log(localType); // \"Identifier\"console.log(localName); // \"bar\" （4） 数组解构 数组解构基本语法 数据解构的语法和对象解构看起来类似，只是将对象字面量替换成了数组字面量，而且解构操作的是数组内部的位置（索引）而不是对象中的命名属性，例如：12345let colors = [ \"red\", \"green\", \"blue\" ];let [ firstColor, secondColor ] = colors;console.log(firstColor); // \"red\"console.log(secondColor); // \"green\" 如果只想取数组中的某一项，则可以不用命名。12345 let colors = [ \"red\", \"green\", \"blue\" ];//只取数组中的第三项。let [ , , thirdColor ] = colors;console.log(thirdColor); // \"blue\" 解构表达式 你可以想要赋值的情况下使用数组的解构赋值表达式，但是和对象解构不同，没必要将它们包含在圆括号中，例如：12345678let colors = [ \"red\", \"green\", \"blue\" ], firstColor = \"black\", secondColor = \"purple\";[ firstColor, secondColor ] = colors; //可以不用加括号。当然添加也不犯法console.log(firstColor); // \"red\"console.log(secondColor); // \"green\" 数组解构表达式有一个很常用的地方，就是交换两个变量的值。在以前一般定义一个第三方变量进行交换，例如下面的代码：12345678910&lt;script type=\"text/javascript\"&gt; let a = 3, b = 4, temp; temp = a; a = b; b = temp; console.log(a); console.log(b)&lt;/script&gt; ES6中完全可以抛弃第三方变量这种方式，使用我们的数组解构表达式12345678&lt;script type=\"text/javascript\"&gt; let a = 3, b = 4; //左侧和前面的案例是一样的，右侧是一个新创建的数组字面量。 [a, b] = [b, a]; console.log(a); console.log(b)&lt;/script&gt; 六. Set数据结构 Set类型是一个包含无重复元素的有序列表 Set本身是一个构造函数。 12345678910&lt;script type=\"text/javascript\"&gt; //创建Set数据结构对象。 var s = new Set(); //调用set对象的add方法，向set中添加元素 s.add(\"a\"); s.add(\"c\"); s.add(\"b\"); //set的size属性可以获取set中元素的个数 console.log(s.size)&lt;/script&gt; Set中不能添加重复元素 使用数组初始化Set12345&lt;script type=\"text/javascript\"&gt; //使用数组中的元素来初始化Set，当然碰到重复的也不会添加进去。 var s = new Set([2, 3, 2, 2, 4]); console.log(s.size)&lt;/script&gt; 判断一个值是否在Set中 使用Set的 has() 方法可以判断一个值是否在这个set中。1234567&lt;script type=\"text/javascript\"&gt; let set = new Set(); set.add(5); set.add(\"5\"); console.log(set.has(5)); // true console.log(set.has(6)); // false&lt;/script&gt; 移除Set中的元素123456789101112131415161718192021delete(要删除的值) ：删除单个值clear()：清空所有的值&lt;script type=\"text/javascript\"&gt; let set = new Set(); set.add(5); set.add(\"5\"); console.log(set.has(5)); // true set.delete(5); console.log(set.has(5)); // false console.log(set.size); // 1 set.clear(); console.log(set.has(\"5\")); // false console.log(set.size); // 0&lt;/script&gt; 遍历Set Set也有forEach可以遍历Set,for…of也可以遍历set 将Set转换为数组 将数组转换为Set相当容易，你只需要在创建Set集合时把数组作为参数传递进去即可。 把Set转换为数组使用前面讲到的扩展运算符也很容易123456&lt;script type=\"text/javascript\"&gt; let set = new Set([1, 2, 3, 3, 3, 4, 5]), arr = [...set]; //使用扩展运算符。那么新的数组中已经没有了重复元素。注意，此对set并没有什么影响 console.log(arr); // [1,2,3,4,5]&lt;/script&gt; 这种情况在需要去数组中重复元素的时候非常好用。123456789&lt;script type=\"text/javascript\"&gt; function eliminateDuplicates(items) &#123; return [...new Set(items)]; &#125; let numbers = [1, 2, 3, 3, 3, 4, 5, 5, 2, 1, 1], //返回的是新的没有重复元素的数组。 noDuplicates = eliminateDuplicates(numbers); console.log(noDuplicates); // [1,2,3,4,5]&lt;/script&gt; Set提供了处理一系列值的方式，不过如果想给这些值添加一些附加数据则显得力不从心，所以又提供了一种新的数据结构：Map 七. Map数据结构 Map创建也是使用Map构造函数向Map存储键值对使用set(key, value);方法可以使用get(key),来获取指定key对应的value1234567891011121314&lt;script type=\"text/javascript\"&gt; var map = new Map(); map.set(\"a\", \"lisi\"); map.set(\"b\", \"zhangsan\"); map.set(\"b\", \"zhangsan222\"); // 第二次添加，新的value会替换掉旧的 console.log(map.get(\"a\")); console.log(map.get(\"b\")); //zhangsan222 console.log(map.get(\"c\")); //undefined.如果key不存在，则返回undefined console.log(map.size); //2&lt;/script&gt;has(key) - 判断给定的 key 是否在 map 中存在delete(key) - 移除 map 中的 key 及对应的值clear() - 移除 map 中所有的键值对 初始化Map 创建Map的时候也可以像Set一样传入数组。但是传入的数组中必须有两个元素，这个两个元素分别是一个数组。 也就是传入的实际是一个二维数组！1234567891011&lt;script type=\"text/javascript\"&gt; //map接受一个二维数组 var map = new Map([ //每一个数组中，第一个是是map的可以，第二个是map的value。如果只有第一个，则值是undefined [\"name\", \"lisi\"], [\"age\", 20], [\"sex\", \"nan\"] ]); console.log(map.size); console.log(map.get(\"name\"))&lt;/script&gt; Map的forEach方法1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt; var map = new Map([ [\"name\", \"李四\"], [\"age\", 20], [\"sex\", \"nan\"] ]); /* 回调函数有函数： 参数1：键值对的value 参数2：键值对的key 参数3：map对象本身 */ map.forEach(function (value, key, ownMap) &#123; console.log(`key=$&#123;key&#125; ,vlue=$&#123;value&#125;`); console.log(this); &#125;) &lt;/script&gt;var colors = [\"red\", \"green\", \"blue\"];for (var i = 0, len = colors.length; i &lt; len; i++) &#123; console.log(colors[i]);&#125; 八. 类 ES5之前的模拟的类，JavaScript 没有类。和类这个概念及行为最接近的是创建一个构造函数并在构造函数的原型上添加方法，这种实现也被称为自定义的类型创建，例如：12345678910111213function PersonType(name) &#123; this.name = name;&#125;PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;let person = new PersonType(\"Nicholas\");person.sayName(); // 输出 \"Nicholas\"console.log(person instanceof PersonType); // trueconsole.log(person instanceof Object); // true (1) ES6中基本的类声明12345678910111213141516171819//class关键字必须是小写。 后面就是跟的类名class PersonClass &#123; // 等效于 PersonType 构造函数。 constructor(name) &#123; //这个表示类的构造函数。constuctor也是关键字必须小写。 this.name = name; //创建属性。 也叫当前类型的自有属性。 &#125; // 等效于 PersonType.prototype.sayName. 这里的sayName使用了我们前面的简写的方式。 sayName() &#123; console.log(this.name); &#125;&#125;let person = new PersonClass(\"Nicholas\");person.sayName(); // 输出 \"Nicholas\"console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // \"function\"console.log(typeof PersonClass.prototype.sayName); // \"function\" 匿名类表达式123456789101112131415161718192021let PersonClass = class &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125;&#125;;let person = new PersonClass(\"Nicholas\");person.sayName(); // 输出 \"Nicholas\"console.log(person instanceof PersonClass); // trueconsole.log(person instanceof Object); // trueconsole.log(typeof PersonClass); // \"function\"console.log(typeof PersonClass.prototype.sayName); // \"function\" 静态成员 在ES5中，我们可以直接给构造函数添加属性或方法来模拟静态成员。123456789101112function PersonType(name) &#123; this.name = name;&#125;// 静态方法。 直接添加到构造方法上。 (其实是把构造函数当做一个普通的对象来用。)PersonType.create = function(name) &#123; return new PersonType(name);&#125;;// 实例方法PersonType.prototype.sayName = function() &#123; console.log(this.name);&#125;;var person = PersonType.create(\"Nicholas\"); ECMAScript 6 的类通过在方法之前使用正式的 static 关键字简化了静态方法的创建。例如，下例中的类和上例相比是等效的：12345678910111213141516171819class PersonClass &#123; // 等效于 PersonType 构造函数 constructor(name) &#123; this.name = name; &#125; // 等效于 PersonType.prototype.sayName sayName() &#123; console.log(this.name); &#125; // 等效于 PersonType.create。 static create(name) &#123; return new PersonClass(name); &#125;&#125;let person = PersonClass.create(\"Nicholas\"); 注意：静态成员通过实例对象不能访问，只能通过类名访问！！！ (2) ES6中的继承 ES6之前要完成继承，需要写很多的代码。看下面的继承的例子：1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt; function Father(name) &#123; this.name = name; &#125; Father.prototype.sayName = function () &#123; console.log(this.name); &#125; function Son(name,age) &#123; Father.call(this, name); this.age = age; &#125; Son.prototype = new Father(); Son.prototype.constructor = Son; Son.prototype.sayAge = function () &#123; console.log(this.age); &#125; var son1 = new Son(\"儿子\", 20); son1.sayAge(); //20 son1.sayName(); //儿子&lt;/script&gt; 如果在ES6通过类的方式完成继承就简单了很多。需要用到一个新的关键字：extends123456789101112131415161718192021222324252627&lt;script type=\"text/javascript\"&gt; class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125; &#125; class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125; &#125; var son1 = new Son(\"李四\", 30); son1.sayAge(); son1.sayName(); console.log(son1 instanceof Son); // true console.log(son1 instanceof Father); //true&lt;/script&gt; 这种继承方法，和我们前面提到的构造函数+原型的继承方式本质是一样的。但是写起来更简单，可读性也更好。 关于super的使用，有几点需要注意： 你只能在派生类中使用 super()，否则（没有使用 extends 的类或函数中使用）一个错误会被抛出。你必须在构造函数的起始位置调用 super()，因为它会初始化 this。任何在 super() 之前访问 this 的行为都会造成错误。也即是说super()必须放在构造函数的首行。在类构造函数中，唯一能避免调用 super() 的办法是返回一个对象。 在子类中屏蔽父类的方法 如果在子类中声明与父类中的同名的方法，则会覆盖父类的方法。(这种情况在其他语言中称之为 方法的覆写、重写 )1234567891011121314151617181920212223242526272829&lt;script type=\"text/javascript\"&gt; class Father&#123; constructor(name)&#123; this.name = name; &#125; sayName()&#123; console.log(this.name); &#125; &#125; class Son extends Father&#123; //extents后面跟表示要继承的类型 constructor(name, age)&#123; super(name); //相当于以前的：Father.call(this, name); this.age = age; &#125; //子类独有的方法 sayAge()&#123; console.log(this.age); &#125; //子类中的方法会屏蔽到父类中的同名方法。 sayName()&#123; super.syaName(); //调用被覆盖的父类中的方法。 console.log(\"我是子类的方法，我屏蔽了父类：\" + name); &#125; &#125; var son1 = new Son(\"李四\", 30); son1.sayAge(); son1.sayName();&lt;/script&gt; 如果在子类中又确实需要调用父类中被覆盖的方法，可以通过super.方法()来完成。 注意： 如果是调用构造方法，则super不要加点，而且必须是在子类构造方法的第一行调用父类的构造方法普通方法调用需要使用super.父类的方法() 来调用。 静态方法也可以继承123456789101112&lt;script type=\"text/javascript\"&gt; class Father&#123; static foo()&#123; console.log(\"我是父类的静态方法\"); &#125; &#125; class Son extends Father&#123; &#125; Son.foo(); //子类也继承了父类的静态方法。 这种方式调用和直接通过父类名调用时一样的。&lt;/script&gt; Array 数组 JavaScript 数组对象是用于构造数组的全局对象; 它是高阶，类似列表的对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213创建数组let fruits = [\"Apple\", \"Banana\"];console.log(fruits.length);// 2通过索引访问 let first = fruits[0];// Applelet last = fruits[fruits.length - 1];// Banana遍历一个数组fruits.forEach(function (item, index, array) &#123; console.log(item, index);&#125;);// Apple 0// Banana 1添加元素到数组的末尾var newLength = fruits.push(\"Orange\");// [\"Apple\", \"Banana\", \"Orange\"]删除数组末尾的元素let last = fruits.pop(); // remove Orange (from the end)// [\"Apple\", \"Banana\"];删除数组最前面（头部）的元素let first = fruits.shift(); // remove Apple from the front// [\"Banana\"];添加到数组的前面（头部）let newLength = fruits.unshift(\"Strawberry\");// add to the front// [\"Strawberry\", \"Banana\"];找到某个元素在数组中的索引fruits.push('Mango');// [\"Strawberry\", \"Banana\", \"Mango\"]let index = fruits.indexOf(\"Banana\");// 1通过索引删除某个元素let removedItem = fruits.splice(pos, 1); // this is how to remove an item// [\"Strawberry\", \"Mango\"]从一个索引位置删除多个元素let vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot'];console.log(vegetables); // [\"Cabbage\", \"Turnip\", \"Radish\", \"Carrot\"]let pos = 1, n = 2;let removedItems = vegetables.splice(pos, n); // this is how to remove items, // n defines the number of items to be removed,// from that position(pos) onward to the end of array.console.log(vegetables); // [\"Cabbage\", \"Carrot\"] (the original array is changed)console.log(removedItems); // [\"Turnip\", \"Radish\"]复制一个数组var shallowCopy = fruits.slice(); // this is how to make a copy// [\"Strawberry\", \"Mango\"]方法Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。Array.from(arrayLike[, mapFn[, thisArg]])类数组对象（拥有一个 length 属性和若干索引属性的任意对象）可遍历对象（你可以从它身上迭代出若干个元素的对象，比如有 Map 和 Set 等）Array from a StringArray.from('foo'); // [\"f\", \"o\", \"o\"]Array from a Setlet s = new Set(['foo', window]); Array.from(s); // [\"foo\", window]Array from a Maplet m = new Map([[1, 2], [2, 4], [4, 8]]);Array.from(m); // [[1, 2], [2, 4], [4, 8]]Array from an Array-like object (arguments)function f() &#123; return Array.from(arguments);&#125;f(1, 2, 3);// [1, 2, 3] Array.isArray()假如一个变量是数组则返回true，否则返回false。Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray(\"foobar\"); // falseArray.isArray(undefined); // false假如不存在 Array.isArray()，则在其他代码之前运行下面的代码将创建该方法。if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]'; &#125;;&#125;Array.of();创建一个有可变数量的参数的新的数组实例，无论参数有多少数量，而且可以是任意类型Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7); // [ , , , , , , ]Array(1, 2, 3); // [1, 2, 3]如果原生不支持的话，在其他代码之前执行以下代码会创建 Array.of() 。if (!Array.of) &#123; Array.of = function() &#123; return Array.prototype.slice.call(arguments); &#125;;&#125; Mutator 方法下面的这些方法会改变调用它们的对象自身的值：Array.prototype.copyWithin() 在数组内部，将一段元素序列拷贝到另一段元素序列上，覆盖原有的值。Array.prototype.fill() 将数组中指定区间的所有元素的值，都替换成某个固定的值。Array.prototype.pop()删除数组的最后一个元素，并返回这个元素。Array.prototype.push()在数组的末尾增加一个或多个元素，并返回数组的新长度。Array.prototype.reverse()颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，原先的最后一个变为第一个。Array.prototype.shift()删除数组的第一个元素，并返回这个元素。Array.prototype.sort()对数组元素进行排序，并返回当前数组。Array.prototype.splice()在任意的位置给数组添加或删除任意个元素。Array.prototype.unshift()在数组的开头增加一个或多个元素，并返回数组的新长度。Accessor 方法下面的这些方法绝对不会改变调用它们的对象的值，只会返回一个新的数组或者返回一个其它的期望值。Array.prototype.concat()返回一个由当前数组和其它若干个数组或者若干个非数组值组合而成的新数组。Array.prototype.includes() 判断当前数组是否包含某指定的值，如果是返回 true，否则返回 false。Array.prototype.join()连接所有数组元素组成一个字符串。Array.prototype.slice()抽取当前数组中的一段元素组合成一个新数组。Array.prototype.toSource() 返回一个表示当前数组字面量的字符串。遮蔽了原型链上的 Object.prototype.toSource() 方法。Array.prototype.toString()返回一个由所有数组元素组合而成的字符串。遮蔽了原型链上的 Object.prototype.toString() 方法。Array.prototype.toLocaleString()返回一个由所有数组元素组合而成的本地化后的字符串。遮蔽了原型链上的 Object.prototype.toLocaleString() 方法。Array.prototype.indexOf()返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。Array.prototype.lastIndexOf()返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。Iteration 方法Array.prototype.forEach()为数组中的每个元素执行一次回调函数。Array.prototype.entries() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。Array.prototype.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。Array.prototype.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。Array.prototype.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。Array.prototype.find() 找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。Array.prototype.findIndex() 找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。Array.prototype.keys() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。Array.prototype.map()返回一个由回调函数的返回值组成的新数组。Array.prototype.reduce()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。Array.prototype.reduceRight()从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。Array.prototype.values() 返回一个数组迭代器对象，该迭代器会包含所有数组元素的值 canvas 使用 canvas 是使用javascript网页上绘制图像画布是一个矩形区域，可以控制其中每一个像素。canvas拥有多种绘制路径，矩形、圆形、字符及添加图像的方法getContext(“2d”) 对象是内建html5对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法fillRect(0,0,150,75) 绘制矩形，从左上角开始（0,0）,画150*75的矩形 12345678910111213141516171819202122232425262728//绘制线条cxt.moveTo(10,10);cxt.lineTo(150,50);cxt.linTo(10, 50);cxt.stroke();//绘制圆形cxt.beginPath();cxt.arc(70,18,15,0,Math.PI*2, true);cxt.closePath();cxt.fill();//绘制图片cxt.drawImage(img,0,0);一下是画三角示例&lt;canvas id=\"triangle\" height=\"100\" width=\"100\"&gt;&lt;/canvas&gt;var canvas = document.getElementById('triangle'); //获取canvas元素var context = canvas.getContext('2d'); //创建context对象context.beginPath();context.moveTo(0,0);context.lineTo(100,0);context.lineTo(50,100);context.closePath();context.fillStyle=\"rgb(78,193,243)\";context.fill(); css盒子模型 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ (1) 有两种， IE 盒子模型、W3C 盒子模型； (2) 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； (3) 区 别： IE的content部分把 border 和 padding计算了进去;1234567.triangle &#123; width : 0; height: 0; border : 100px solid transparent; border-top : 100px solid blue; /*这里可以设置border的top、bottom、left、right四个方向的三角&#125;&lt;div class=\"triangle\"&gt;&lt;/div&gt; 在实际设计中，我们会发现，IE 盒模型更容易进行控制，我们一般先将整个容器的尺寸先确定，然后再填充具体的内容，通过 padding 来调整内容的具体位置，通过 margin 来调整容器与其他元素之间的间隙，无论如何调整，整个容器的结构是固定的，不会改变的；而在标准盒模型中，我们在调整 padding 和 margin 的同时，往往会将容器本身的结构打乱，需要重新设置内容 content 的尺寸 所以我一般都会在样式重置中添加 CSS 3 属性：box-sizing: border-box; 可以让元素按照 IE 盒模型进行解析，即设置的宽高包括了 border 以及 padding 的值 标准模型的盒子大小(280X280) = 200 +102 + 302 — 相加效果 传统IE6盒子大小(200X200) = 120 + 10 2 + 302 — 减去效果 js有5种基本数据类型，null, undefind, number, boolean, string,和一种对象数据类型（Oject, Array, Date）.","categories":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/tags/前端/"},{"name":"javaScript","slug":"javaScript","permalink":"//website.cwzcfj.cn/tags/javaScript/"},{"name":"ES6","slug":"ES6","permalink":"//website.cwzcfj.cn/tags/ES6/"},{"name":"js面向对象","slug":"js面向对象","permalink":"//website.cwzcfj.cn/tags/js面向对象/"},{"name":"闭包","slug":"闭包","permalink":"//website.cwzcfj.cn/tags/闭包/"}]},{"title":"React Native APi AsyncStorage的使用","slug":"react-native存储AsyncStorage","date":"2019-04-15T14:18:34.000Z","updated":"2022-09-04T08:35:21.793Z","comments":false,"path":"2019/04/15/react-native存储AsyncStorage/","link":"","permalink":"//website.cwzcfj.cn/2019/04/15/react-native存储AsyncStorage/","excerpt":"","text":"React Native APi AsyncStorage的使用。简介 AsyncStorage是一个简单的、异步、持久的key-value存储系统，它对于App来说是全局的。用来替换LocalStorage。推荐您使用AsyncStorage基础上做一层抽象的封装，而不是直接使用。 地址：https://github.com/sunnylqm/react-native-storage 方法 AsyncStorage里面都有一个回调，而回调第一个参数都是错误对象，如果发生错误，就返回该对象的错误信息，否则为null。每个方法都返回一个promise对象。12345678910static getItem(key:string , callback:(error,result)): 根据键来获取值，获取的结果会在回调函数中。static setItem(key:string , value:string , callback:(error)): 设置键值对。static removeItem(key:string , callback:(error)): 将根据键移出一项static mergeItem:(key:string , value:string , callback:(error)): 合并现有的值和输入值。static clear(callback:(error)): 清除所有的项目。static getAllKeys(callback:(error)): 获取所有的键。static multiGet(keys,callback:(errors,result)):获取多项，其中keys是字符串数组。static multiSet(keyValuePairs,callback:(errors)):设置多项，其中keyValuePairs是字符串的二维数组。static multiRemove(keys,callback(errors)):删除多项，其中keys是字符串数组。static multiMerge(keyValuePairs,callback:(errors)):多个键值合并，其中keyValuePairs是字符串中的二维数组。","categories":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"//website.cwzcfj.cn/tags/前端/"},{"name":"react-native","slug":"react-native","permalink":"//website.cwzcfj.cn/tags/react-native/"},{"name":"AsyncStorage","slug":"AsyncStorage","permalink":"//website.cwzcfj.cn/tags/AsyncStorage/"}]}]}